{"version":3,"sources":["webpack:///./node_modules/ngx-img-cropper/index.js","webpack:///./node_modules/ngx-img-cropper/src/cropperDrawSettings.js","webpack:///./node_modules/ngx-img-cropper/src/cropperSettings.js","webpack:///./node_modules/ngx-img-cropper/src/exif.js","webpack:///./node_modules/ngx-img-cropper/src/imageCropper.js","webpack:///./node_modules/ngx-img-cropper/src/imageCropperComponent.js","webpack:///./node_modules/ngx-img-cropper/src/imageCropperDataShare.js","webpack:///./node_modules/ngx-img-cropper/src/imageCropperModule.js","webpack:///./node_modules/ngx-img-cropper/src/model/bounds.js","webpack:///./node_modules/ngx-img-cropper/src/model/cornerMarker.js","webpack:///./node_modules/ngx-img-cropper/src/model/cropPosition.js","webpack:///./node_modules/ngx-img-cropper/src/model/cropTouch.js","webpack:///./node_modules/ngx-img-cropper/src/model/dragMarker.js","webpack:///./node_modules/ngx-img-cropper/src/model/handle.js","webpack:///./node_modules/ngx-img-cropper/src/model/imageCropperModel.js","webpack:///./node_modules/ngx-img-cropper/src/model/point.js","webpack:///./node_modules/ngx-img-cropper/src/model/pointPool.js","webpack:///./node_modules/ngx-owl-carousel/index.js","webpack:///./node_modules/ngx-owl-carousel/src/owl-carousel.component.js","webpack:///./node_modules/ngx-owl-carousel/src/owl-child.component.js","webpack:///./src/app/auth.guard.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8D;AACM;AACpE;AACkD;AACM;AACQ;AAChE;AAC4C;AACY;AACxD,iC;;;;;;;;;;;;ACVA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC8B;AAC/B,+C;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wEAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AAC0B;AAC3B,2C;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,IAAI;AAC/C;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACe;AAChB,gC;;;;;;;;;;;;ACzxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACuC;AACY;AACN;AACE;AACc;AACE;AAClB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAS;AACvC,uBAAuB,gEAAY;AACnC,uBAAuB,gEAAY;AACnC,uBAAuB,gEAAY;AACnC,uBAAuB,gEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAS;AACxB;AACA;AACA;AACA,eAAe,0DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAS,iDAAiD,0DAAS;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAS,iDAAiD,0DAAS;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAS,iDAAiD,0DAAS;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAS,iDAAiD,0DAAS;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAS;AACjB,QAAQ,0DAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAS;AACzB,oDAAoD,gEAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4EAAqB;AACrC;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,4BAA4B;AACnF;AACA,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B;AACA;AACA;AACA;AACA,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B;AACA,iBAAiB,0DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA,yEAAyE;AACzE;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B,oBAAoB,0DAAS;AAC7B,qBAAqB,0DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA,4CAA4C,0DAAS;AACrD,wBAAwB,0DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yKAAyK;AACzK;AACA;AACA;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA,8KAA8K;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAS;AACzC;AACA,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4EAAqB;AACrC;AACA;AACA,iFAAiF,gEAAY;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA,gBAAgB,4EAAqB;AACrC;AACA;AACA;AACA;AACA,YAAY,4EAAqB;AACjC,YAAY,4EAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAqB;AACzC,oBAAoB,4EAAqB;AACzC;AACA;AACA,oBAAoB,4EAAqB;AACzC,oBAAoB,4EAAqB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,4EAAqB;AACzC,oBAAoB,4EAAqB;AACzC;AACA;AACA,oBAAoB,4EAAqB;AACzC,oBAAoB,4EAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAS;AACzC,YAAY,0DAAS;AACrB;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA,wDAAwD,gEAAY,oCAAoC,4DAAU;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAAqB;AACjC;AACA,mCAAmC,0DAAS;AAC5C;AACA;AACA;AACA,CAAC,CAAC,0EAAiB;AACK;AACxB,wC;;;;;;;;;;;;ACtkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACyG;AAC3D;AACM;AACtB;AACsB;AACpD;AACA;AACA,sCAAsC,0DAAY;AAClD,0BAA0B,0DAAY;AACtC,4BAA4B,0DAAY;AACxC;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAY;AACrD;AACA;AACA;AACA;AACA,QAAQ,0CAAI;AACZ,8BAA8B,0CAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,+DAAS;AACjB,kCAAkC,wDAAU;AAC5C;AACA;AACA,QAAQ,+DAAS;AACjB,kCAAkC,wDAAU;AAC5C;AACA;AACA,QAAQ,2DAAK;AACb,kCAAkC,gEAAe;AACjD;AACA;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA,QAAQ,2DAAK;AACb,kCAAkC,0DAAY;AAC9C;AACA;AACA,QAAQ,2DAAK;AACb,kCAAkC,gEAAY;AAC9C;AACA;AACA,QAAQ,4DAAM;AACd,kCAAkC,0DAAY;AAC9C;AACA;AACA,QAAQ,4DAAM;AACd,kCAAkC,0DAAY;AAC9C;AACA;AACA,QAAQ,4DAAM;AACd,kCAAkC,0DAAY;AAC9C;AACA;AACA,QAAQ,+DAAS;AACjB;AACA;AACA,SAAS;AACT,yCAAyC,uDAAS;AAClD;AACA;AACA,CAAC;AACgC;AACjC,iD;;;;;;;;;;;;ACvRA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgC;AACjC,iD;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AAC+C;AACN;AACuB;AAChE;AACA;AACA;AACA;AACA,QAAQ,8DAAQ;AAChB,sBAAsB,4DAAY;AAClC,2BAA2B,4EAAqB;AAChD,sBAAsB,4EAAqB;AAC3C,SAAS;AACT;AACA;AACA,CAAC;AAC6B;AAC9B,8C;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,oDAAS;AACxB;AACA;AACA,CAAC;AACiB;AAClB,kC;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACiC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8CAAM;AACgB;AACxB,wC;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAkC;AAClC;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB,wC;;;;;;;;;;;;ACrBA;AAAA;AAAA;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB,qC;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACiC;AACM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B,iBAAiB,oDAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAS;AACjB;AACA;AACA,CAAC,CAAC,8CAAM;AACc;AACtB,sC;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAgC;AACqB;AACrD;AACA;AACA,mCAAmC,gEAAe;AAClD;AACA;AACA,6BAA6B,4CAAK;AAClC,0BAA0B,4CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACiB;AAClB,kC;;;;;;;;;;;;AC1CA;AAAA;AAAA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B,6C;;;;;;;;;;;;ACNA;AAAA;AAAA;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACgB;AACjB,iC;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAgC;AAChC;AACA;AACA;AACA,8CAA8C,4CAAK;AACnD,uBAAuB,iBAAiB;AACxC,wBAAwB,4CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB,qC;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,iEAAe;AACpC,eAAe,mBAAO,CAAC,uEAAiB;AACxC,+BAA+B,mBAAO,CAAC,mGAA8B;AACrE,4BAA4B,mBAAO,CAAC,6FAA2B;AAC/D,SAAS,mBAAO,CAAC,mGAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,iC;;;;;;;;;;;;ACtCa;AACb;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,iEAAe;AACpC,4BAA4B,mBAAO,CAAC,yFAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,kD;;;;;;;;;;;;ACzGa;AACb;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,iEAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,+C;;;;;;;;;;;;;;;;;;;;AC7EA;;;;;;;;wDAQwD;AACb;AAGN;AACmB;AACf;AAIzC;IACE;;;;;;MAME;IACF,mBAAoB,QAAuB,EAAU,MAAc;QAA/C,aAAQ,GAAR,QAAQ,CAAe;QAAU,WAAM,GAAN,MAAM,CAAQ;IAAG,CAAC;IAEvE;;;;;;MAME;IACF,+BAAW,GAAX,UACE,IAA4B,EAC5B,KAA0B;QAF5B,iBAaC;QATC,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,0DAAG,CAAC,UAAC,QAAa;YACrD,IAAI,QAAQ,CAAC,MAAM,KAAK,SAAS,EAAE;gBACjC,OAAO,IAAI,CAAC;aACb;iBAAM;gBACL,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,wCAAwC;gBACpE,OAAO,KAAK,CAAC;aACd;QACL,CAAC,CAAC,CAAC,CAAC;IAEN,CAAC;IA9BU,SAAS;QAHrB,gEAAU,CAAC;YACV,UAAU,EAAE,MAAM;SACnB,CAAC;+EAS8B,sEAAa,EAAkB,sDAAM;OARxD,SAAS,CA+BrB;IAAD,gBAAC;CAAA;AA/BqB","file":"default~cvbuilder-cvbuilder-module~profile-profile-module.js","sourcesContent":["// core\r\nexport { ImageCropperModule } from './src/imageCropperModule';\r\nexport { ImageCropperComponent } from './src/imageCropperComponent';\r\n// extra classes\r\nexport { ImageCropper } from './src/imageCropper';\r\nexport { CropperSettings } from './src/cropperSettings';\r\nexport { CropperDrawSettings } from './src/cropperDrawSettings';\r\n// models\r\nexport { Bounds } from './src/model/bounds';\r\nexport { CropPosition } from './src/model/cropPosition';\r\n//# sourceMappingURL=index.js.map","var CropperDrawSettings = /** @class */ (function () {\r\n    function CropperDrawSettings(settings) {\r\n        this.lineDash = false;\r\n        this.strokeWidth = 1;\r\n        this.strokeColor = \"rgba(255,255,255,1)\";\r\n        this.dragIconStrokeWidth = 1;\r\n        this.dragIconStrokeColor = \"rgba(0,0,0,1)\";\r\n        this.dragIconFillColor = \"rgba(255,255,255,1)\";\r\n        if (typeof settings === \"object\") {\r\n            this.lineDash = settings.lineDash || this.lineDash;\r\n            this.strokeWidth = settings.strokeWidth || this.strokeWidth;\r\n            this.strokeColor = settings.strokeColor || this.strokeColor;\r\n            this.dragIconStrokeWidth =\r\n                settings.dragIconStrokeWidth || this.dragIconStrokeWidth;\r\n            this.dragIconStrokeColor =\r\n                settings.dragIconStrokeColor || this.dragIconStrokeColor;\r\n            this.dragIconFillColor =\r\n                settings.dragIconFillColor || this.dragIconFillColor;\r\n        }\r\n    }\r\n    return CropperDrawSettings;\r\n}());\r\nexport { CropperDrawSettings };\r\n//# sourceMappingURL=cropperDrawSettings.js.map","import { CropperDrawSettings } from \"./cropperDrawSettings\";\r\nvar CropperSettings = /** @class */ (function () {\r\n    function CropperSettings(settings) {\r\n        this.canvasWidth = 300;\r\n        this.canvasHeight = 300;\r\n        this.dynamicSizing = false;\r\n        this.width = 200;\r\n        this.height = 200;\r\n        this.minWidth = 50;\r\n        this.minHeight = 50;\r\n        this.minWithRelativeToResolution = true;\r\n        this.croppedWidth = 100;\r\n        this.croppedHeight = 100;\r\n        this.cropperDrawSettings = new CropperDrawSettings();\r\n        this.touchRadius = 20;\r\n        this.noFileInput = false;\r\n        this.markerSizeMultiplier = 1;\r\n        this.centerTouchRadius = 20;\r\n        this.showCenterMarker = true;\r\n        this.allowedFilesRegex = /\\.(jpe?g|png|gif|bmp)$/i;\r\n        this.cropOnResize = true;\r\n        this.preserveSize = false;\r\n        this.compressRatio = 1.0;\r\n        this._rounded = false;\r\n        this._keepAspect = true;\r\n        if (typeof settings === \"object\") {\r\n            Object.assign(this, settings);\r\n        }\r\n    }\r\n    Object.defineProperty(CropperSettings.prototype, \"rounded\", {\r\n        get: function () {\r\n            return this._rounded;\r\n        },\r\n        set: function (val) {\r\n            this._rounded = val;\r\n            if (val) {\r\n                this._keepAspect = true;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CropperSettings.prototype, \"keepAspect\", {\r\n        get: function () {\r\n            return this._keepAspect;\r\n        },\r\n        set: function (val) {\r\n            this._keepAspect = val;\r\n            if (this._rounded === true && this._keepAspect === false) {\r\n                console.error(\"Cannot set keep aspect to false on rounded cropper. Ellipsis not supported\");\r\n                this._keepAspect = true;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return CropperSettings;\r\n}());\r\nexport { CropperSettings };\r\n//# sourceMappingURL=cropperSettings.js.map","var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar Fraction = /** @class */ (function (_super) {\r\n    __extends(Fraction, _super);\r\n    function Fraction() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Fraction;\r\n}(Number));\r\nexport { Fraction };\r\n// Console debug wrapper that makes code looks a little bit cleaner\r\nvar Debug = /** @class */ (function () {\r\n    function Debug() {\r\n    }\r\n    Debug.log = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (Exif.debug) {\r\n            console.log(args);\r\n        }\r\n    };\r\n    return Debug;\r\n}());\r\nexport { Debug };\r\nvar Exif = /** @class */ (function () {\r\n    function Exif() {\r\n    }\r\n    Exif.addEvent = function (element, event, handler) {\r\n        if (element.addEventListener) {\r\n            element.addEventListener(event, handler, false);\r\n        }\r\n        else {\r\n            // Hello, IE!\r\n            if (element.attachEvent) {\r\n                element.attachEvent(\"on\" + event, handler);\r\n            }\r\n        }\r\n    };\r\n    Exif.imageHasData = function (img) {\r\n        return !!img.exifdata;\r\n    };\r\n    Exif.base64ToArrayBuffer = function (base64) {\r\n        base64 = base64.replace(/^data:([^;]+);base64,/gim, \"\");\r\n        var binary = atob(base64);\r\n        var len = binary.length;\r\n        var buffer = new ArrayBuffer(len);\r\n        var view = new Uint8Array(buffer);\r\n        for (var i = 0; i < len; i++) {\r\n            view[i] = binary.charCodeAt(i);\r\n        }\r\n        return buffer;\r\n    };\r\n    Exif.objectURLToBlob = function (url, callback) {\r\n        var http = new XMLHttpRequest();\r\n        http.open(\"GET\", url, true);\r\n        http.responseType = \"blob\";\r\n        http.onload = function () {\r\n            if (http.status === 200 || http.status === 0) {\r\n                callback(http.response);\r\n            }\r\n        };\r\n        http.send();\r\n    };\r\n    Exif.getImageData = function (img, callback) {\r\n        function handleBinaryFile(binFile) {\r\n            var data = Exif.findEXIFinJPEG(binFile);\r\n            var iptcdata = Exif.findIPTCinJPEG(binFile);\r\n            img.exifdata = data || {};\r\n            img.iptcdata = iptcdata || {};\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n        if (\"src\" in img && img.src) {\r\n            if (/^data:/i.test(img.src)) {\r\n                // Data URI\r\n                var arrayBuffer = Exif.base64ToArrayBuffer(img.src);\r\n                handleBinaryFile(arrayBuffer);\r\n            }\r\n            else {\r\n                if (/^blob:/i.test(img.src)) {\r\n                    // Object URL\r\n                    var fileReader_1 = new FileReader();\r\n                    fileReader_1.onload = function (e) {\r\n                        handleBinaryFile(e.target.result);\r\n                    };\r\n                    Exif.objectURLToBlob(img.src, function (blob) {\r\n                        fileReader_1.readAsArrayBuffer(blob);\r\n                    });\r\n                }\r\n                else {\r\n                    var http_1 = new XMLHttpRequest();\r\n                    http_1.onload = function () {\r\n                        if (http_1.status === 200 || http_1.status === 0) {\r\n                            handleBinaryFile(http_1.response);\r\n                        }\r\n                        else {\r\n                            throw \"Could not load image\";\r\n                        }\r\n                    };\r\n                    http_1.open(\"GET\", img.src, true);\r\n                    http_1.responseType = \"arraybuffer\";\r\n                    http_1.send(null);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (FileReader && (img instanceof Blob || img instanceof File)) {\r\n                var fileReader = new FileReader();\r\n                fileReader.onload = function (e) {\r\n                    Debug.log(\"Got file of length \" + e.target.result.byteLength);\r\n                    handleBinaryFile(e.target.result);\r\n                };\r\n                fileReader.readAsArrayBuffer(img);\r\n            }\r\n        }\r\n    };\r\n    Exif.findEXIFinJPEG = function (file) {\r\n        var dataView = new DataView(file);\r\n        Debug.log(\"Got file of length \" + file.byteLength);\r\n        if (dataView.getUint8(0) !== 0xff || dataView.getUint8(1) !== 0xd8) {\r\n            Debug.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n        var offset = 2;\r\n        var length = file.byteLength;\r\n        var marker;\r\n        while (offset < length) {\r\n            if (dataView.getUint8(offset) !== 0xff) {\r\n                Debug.log(\"Not a valid marker at offset \" +\r\n                    offset +\r\n                    \", found: \" +\r\n                    dataView.getUint8(offset));\r\n                return false; // not a valid marker, something is wrong\r\n            }\r\n            marker = dataView.getUint8(offset + 1);\r\n            Debug.log(marker);\r\n            // we could implement handling for other markers here,\r\n            // but we're only looking for 0xFFE1 for EXIF data\r\n            if (marker === 225) {\r\n                Debug.log(\"Found 0xFFE1 marker\");\r\n                return Exif.readEXIFData(dataView, offset + 4); // , dataView.getUint16(offset + 2) - 2);\r\n                // offset += 2 + file.getShortAt(offset+2, true);\r\n            }\r\n            else {\r\n                offset += 2 + dataView.getUint16(offset + 2);\r\n            }\r\n        }\r\n    };\r\n    Exif.findIPTCinJPEG = function (file) {\r\n        var dataView = new DataView(file);\r\n        Debug.log(\"Got file of length \" + file.byteLength);\r\n        if (dataView.getUint8(0) !== 0xff || dataView.getUint8(1) !== 0xd8) {\r\n            Debug.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n        var offset = 2;\r\n        var length = file.byteLength;\r\n        var isFieldSegmentStart = function (_dataView, _offset) {\r\n            return (_dataView.getUint8(_offset) === 0x38 &&\r\n                _dataView.getUint8(_offset + 1) === 0x42 &&\r\n                _dataView.getUint8(_offset + 2) === 0x49 &&\r\n                _dataView.getUint8(_offset + 3) === 0x4d &&\r\n                _dataView.getUint8(_offset + 4) === 0x04 &&\r\n                _dataView.getUint8(_offset + 5) === 0x04);\r\n        };\r\n        while (offset < length) {\r\n            if (isFieldSegmentStart(dataView, offset)) {\r\n                // Get the length of the name header (which is padded to an even number of bytes)\r\n                var nameHeaderLength = dataView.getUint8(offset + 7);\r\n                if (nameHeaderLength % 2 !== 0) {\r\n                    nameHeaderLength += 1;\r\n                }\r\n                // Check for pre photoshop 6 format\r\n                if (nameHeaderLength === 0) {\r\n                    // Always 4\r\n                    nameHeaderLength = 4;\r\n                }\r\n                var startOffset = offset + 8 + nameHeaderLength;\r\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\r\n                return Exif.readIPTCData(file, startOffset, sectionLength);\r\n            }\r\n            // Not the marker, continue searching\r\n            offset++;\r\n        }\r\n    };\r\n    Exif.readIPTCData = function (file, startOffset, sectionLength) {\r\n        var dataView = new DataView(file);\r\n        var data = {};\r\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\r\n        var segmentStartPos = startOffset;\r\n        while (segmentStartPos < startOffset + sectionLength) {\r\n            if (dataView.getUint8(segmentStartPos) === 0x1c &&\r\n                dataView.getUint8(segmentStartPos + 1) === 0x02) {\r\n                segmentType = dataView.getUint8(segmentStartPos + 2);\r\n                if (segmentType in Exif.IptcFieldMap) {\r\n                    dataSize = dataView.getInt16(segmentStartPos + 3);\r\n                    segmentSize = dataSize + 5;\r\n                    fieldName = Exif.IptcFieldMap[segmentType];\r\n                    fieldValue = Exif.getStringFromDB(dataView, segmentStartPos + 5, dataSize);\r\n                    // Check if we already stored a value with this name\r\n                    if (data.hasOwnProperty(fieldName)) {\r\n                        // Value already stored with this name, create multivalue field\r\n                        if (data[fieldName] instanceof Array) {\r\n                            data[fieldName].push(fieldValue);\r\n                        }\r\n                        else {\r\n                            data[fieldName] = [data[fieldName], fieldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        data[fieldName] = fieldValue;\r\n                    }\r\n                }\r\n            }\r\n            segmentStartPos++;\r\n        }\r\n        return data;\r\n    };\r\n    Exif.readTags = function (file, tiffStart, dirStart, strings, bigEnd) {\r\n        var entries = file.getUint16(dirStart, !bigEnd);\r\n        var tags = {};\r\n        var entryOffset;\r\n        var tag;\r\n        for (var i = 0; i < entries; i++) {\r\n            entryOffset = dirStart + i * 12 + 2;\r\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\r\n            if (!tag) {\r\n                Debug.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\r\n            }\r\n            tags[tag] = Exif.readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\r\n        }\r\n        return tags;\r\n    };\r\n    Exif.readTagValue = function (file, entryOffset, tiffStart, dirStart, bigEnd) {\r\n        var type = file.getUint16(entryOffset + 2, !bigEnd);\r\n        var numValues = file.getUint32(entryOffset + 4, !bigEnd);\r\n        var valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart;\r\n        var offset;\r\n        var vals, val, n;\r\n        var numerator;\r\n        var denominator;\r\n        switch (type) {\r\n            case 1: // byte, 8-bit unsigned int\r\n            case 7: // undefined, 8-bit byte, value depending on field\r\n                if (numValues === 1) {\r\n                    return file.getUint8(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    offset = numValues > 4 ? valueOffset : entryOffset + 8;\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getUint8(offset + n);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 2: // ascii, 8-bit byte\r\n                offset = numValues > 4 ? valueOffset : entryOffset + 8;\r\n                return Exif.getStringFromDB(file, offset, numValues - 1);\r\n            case 3: // short, 16 bit int\r\n                if (numValues === 1) {\r\n                    return file.getUint16(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    offset = numValues > 2 ? valueOffset : entryOffset + 8;\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getUint16(offset + 2 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 4: // long, 32 bit int\r\n                if (numValues === 1) {\r\n                    return file.getUint32(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 5: // rational = two long values, first is numerator, second is denominator\r\n                if (numValues === 1) {\r\n                    numerator = file.getUint32(valueOffset, !bigEnd);\r\n                    denominator = file.getUint32(valueOffset + 4, !bigEnd);\r\n                    val = new Fraction(numerator / denominator);\r\n                    val.numerator = numerator;\r\n                    val.denominator = denominator;\r\n                    return val;\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);\r\n                        denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);\r\n                        vals[n] = new Fraction(numerator / denominator);\r\n                        vals[n].numerator = numerator;\r\n                        vals[n].denominator = denominator;\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 9: // slong, 32 bit signed int\r\n                if (numValues === 1) {\r\n                    return file.getInt32(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\r\n                if (numValues === 1) {\r\n                    return (file.getInt32(valueOffset, !bigEnd) /\r\n                        file.getInt32(valueOffset + 4, !bigEnd));\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] =\r\n                            file.getInt32(valueOffset + 8 * n, !bigEnd) /\r\n                                file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            default:\r\n                break;\r\n        }\r\n    };\r\n    Exif.getStringFromDB = function (buffer, start, length) {\r\n        var outstr = \"\";\r\n        for (var n = start; n < start + length; n++) {\r\n            outstr += String.fromCharCode(buffer.getUint8(n));\r\n        }\r\n        return outstr;\r\n    };\r\n    Exif.readEXIFData = function (file, start) {\r\n        if (Exif.getStringFromDB(file, start, 4) !== \"Exif\") {\r\n            Debug.log(\"Not valid EXIF data! \" + Exif.getStringFromDB(file, start, 4));\r\n            return false;\r\n        }\r\n        var bigEnd, tags, tag, exifData, gpsData, tiffOffset = start + 6;\r\n        // test for TIFF validity and endianness\r\n        if (file.getUint16(tiffOffset) === 0x4949) {\r\n            bigEnd = false;\r\n        }\r\n        else {\r\n            if (file.getUint16(tiffOffset) === 0x4d4d) {\r\n                bigEnd = true;\r\n            }\r\n            else {\r\n                Debug.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\r\n                return false;\r\n            }\r\n        }\r\n        if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\r\n            Debug.log(\"Not valid TIFF data! (no 0x002A)\");\r\n            return false;\r\n        }\r\n        var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);\r\n        if (firstIFDOffset < 0x00000008) {\r\n            Debug.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset + 4, !bigEnd));\r\n            return false;\r\n        }\r\n        tags = Exif.readTags(file, tiffOffset, tiffOffset + firstIFDOffset, Exif.TiffTags, bigEnd);\r\n        if (tags.ExifIFDPointer) {\r\n            exifData = Exif.readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, Exif.Tags, bigEnd);\r\n            for (tag in exifData) {\r\n                if ({}.hasOwnProperty.call(exifData, tag)) {\r\n                    switch (tag) {\r\n                        case \"LightSource\":\r\n                        case \"Flash\":\r\n                        case \"MeteringMode\":\r\n                        case \"ExposureProgram\":\r\n                        case \"SensingMethod\":\r\n                        case \"SceneCaptureType\":\r\n                        case \"SceneType\":\r\n                        case \"CustomRendered\":\r\n                        case \"WhiteBalance\":\r\n                        case \"GainControl\":\r\n                        case \"Contrast\":\r\n                        case \"Saturation\":\r\n                        case \"Sharpness\":\r\n                        case \"SubjectDistanceRange\":\r\n                        case \"FileSource\":\r\n                            exifData[tag] = Exif.StringValues[tag][exifData[tag]];\r\n                            break;\r\n                        case \"ExifVersion\":\r\n                        case \"FlashpixVersion\":\r\n                            exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\r\n                            break;\r\n                        case \"ComponentsConfiguration\":\r\n                            var compopents = \"Components\";\r\n                            exifData[tag] =\r\n                                Exif.StringValues[compopents][exifData[tag][0]] +\r\n                                    Exif.StringValues[compopents][exifData[tag][1]] +\r\n                                    Exif.StringValues[compopents][exifData[tag][2]] +\r\n                                    Exif.StringValues[compopents][exifData[tag][3]];\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    tags[tag] = exifData[tag];\r\n                }\r\n            }\r\n        }\r\n        if (tags.GPSInfoIFDPointer) {\r\n            gpsData = Exif.readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, Exif.GPSTags, bigEnd);\r\n            for (tag in gpsData) {\r\n                if ({}.hasOwnProperty.call(gpsData, tag)) {\r\n                    switch (tag) {\r\n                        case \"GPSVersionID\":\r\n                            gpsData[tag] =\r\n                                gpsData[tag][0] +\r\n                                    \".\" +\r\n                                    gpsData[tag][1] +\r\n                                    \".\" +\r\n                                    gpsData[tag][2] +\r\n                                    \".\" +\r\n                                    gpsData[tag][3];\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    tags[tag] = gpsData[tag];\r\n                }\r\n            }\r\n        }\r\n        return tags;\r\n    };\r\n    //   get rid of this silly issue\r\n    Exif.checkImageType = function (img) {\r\n        return img instanceof Image || img instanceof HTMLImageElement;\r\n    };\r\n    Exif.getData = function (img, callback) {\r\n        if (this.checkImageType(img) && !img.complete) {\r\n            return false;\r\n        }\r\n        if (!Exif.imageHasData(img)) {\r\n            Exif.getImageData(img, callback);\r\n        }\r\n        else {\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Exif.getTag = function (img, tag) {\r\n        if (!Exif.imageHasData(img)) {\r\n            return;\r\n        }\r\n        return img.exifdata[tag];\r\n    };\r\n    Exif.getAllTags = function (img) {\r\n        if (!Exif.imageHasData(img)) {\r\n            return {};\r\n        }\r\n        var a, data = img.exifdata, tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    };\r\n    Exif.pretty = function (img) {\r\n        if (!Exif.imageHasData(img)) {\r\n            return \"\";\r\n        }\r\n        var a, data = img.exifdata, strPretty = \"\";\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                if (typeof data[a] === \"object\") {\r\n                    if (data[a] instanceof Number) {\r\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\r\n                    }\r\n                    else {\r\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\r\n                    }\r\n                }\r\n                else {\r\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\r\n                }\r\n            }\r\n        }\r\n        return strPretty;\r\n    };\r\n    Exif.readFromBinaryFile = function (file) {\r\n        return Exif.findEXIFinJPEG(file);\r\n    };\r\n    Exif.debug = false;\r\n    Exif.IptcFieldMap = {\r\n        0x78: \"caption\",\r\n        0x6e: \"credit\",\r\n        0x19: \"keywords\",\r\n        0x37: \"dateCreated\",\r\n        0x50: \"byline\",\r\n        0x55: \"bylineTitle\",\r\n        0x7a: \"captionWriter\",\r\n        0x69: \"headline\",\r\n        0x74: \"copyright\",\r\n        0x0f: \"category\"\r\n    };\r\n    Exif.Tags = {\r\n        // version tags\r\n        0x9000: \"ExifVersion\",\r\n        0xa000: \"FlashpixVersion\",\r\n        // colorspace tags\r\n        0xa001: \"ColorSpace\",\r\n        // image configuration\r\n        0xa002: \"PixelXDimension\",\r\n        0xa003: \"PixelYDimension\",\r\n        0x9101: \"ComponentsConfiguration\",\r\n        0x9102: \"CompressedBitsPerPixel\",\r\n        // user information\r\n        0x927c: \"MakerNote\",\r\n        0x9286: \"UserComment\",\r\n        // related file\r\n        0xa004: \"RelatedSoundFile\",\r\n        // date and time\r\n        0x9003: \"DateTimeOriginal\",\r\n        0x9004: \"DateTimeDigitized\",\r\n        0x9290: \"SubsecTime\",\r\n        0x9291: \"SubsecTimeOriginal\",\r\n        0x9292: \"SubsecTimeDigitized\",\r\n        // picture-taking conditions\r\n        0x829a: \"ExposureTime\",\r\n        0x829d: \"FNumber\",\r\n        0x8822: \"ExposureProgram\",\r\n        0x8824: \"SpectralSensitivity\",\r\n        0x8827: \"ISOSpeedRatings\",\r\n        0x8828: \"OECF\",\r\n        0x9201: \"ShutterSpeedValue\",\r\n        0x9202: \"ApertureValue\",\r\n        0x9203: \"BrightnessValue\",\r\n        0x9204: \"ExposureBias\",\r\n        0x9205: \"MaxApertureValue\",\r\n        0x9206: \"SubjectDistance\",\r\n        0x9207: \"MeteringMode\",\r\n        0x9208: \"LightSource\",\r\n        0x9209: \"Flash\",\r\n        0x9214: \"SubjectArea\",\r\n        0x920a: \"FocalLength\",\r\n        0xa20b: \"FlashEnergy\",\r\n        0xa20c: \"SpatialFrequencyResponse\",\r\n        0xa20e: \"FocalPlaneXResolution\",\r\n        0xa20f: \"FocalPlaneYResolution\",\r\n        0xa210: \"FocalPlaneResolutionUnit\",\r\n        0xa214: \"SubjectLocation\",\r\n        0xa215: \"ExposureIndex\",\r\n        0xa217: \"SensingMethod\",\r\n        0xa300: \"FileSource\",\r\n        0xa301: \"SceneType\",\r\n        0xa302: \"CFAPattern\",\r\n        0xa401: \"CustomRendered\",\r\n        0xa402: \"ExposureMode\",\r\n        0xa403: \"WhiteBalance\",\r\n        0xa404: \"DigitalZoomRation\",\r\n        0xa405: \"FocalLengthIn35mmFilm\",\r\n        0xa406: \"SceneCaptureType\",\r\n        0xa407: \"GainControl\",\r\n        0xa408: \"Contrast\",\r\n        0xa409: \"Saturation\",\r\n        0xa40a: \"Sharpness\",\r\n        0xa40b: \"DeviceSettingDescription\",\r\n        0xa40c: \"SubjectDistanceRange\",\r\n        // other tags\r\n        0xa005: \"InteroperabilityIFDPointer\",\r\n        0xa420: \"ImageUniqueID\" // Identifier assigned uniquely to each image\r\n    };\r\n    Exif.TiffTags = {\r\n        0x0100: \"ImageWidth\",\r\n        0x0101: \"ImageHeight\",\r\n        0x8769: \"ExifIFDPointer\",\r\n        0x8825: \"GPSInfoIFDPointer\",\r\n        0xa005: \"InteroperabilityIFDPointer\",\r\n        0x0102: \"BitsPerSample\",\r\n        0x0103: \"Compression\",\r\n        0x0106: \"PhotometricInterpretation\",\r\n        0x0112: \"Orientation\",\r\n        0x0115: \"SamplesPerPixel\",\r\n        0x011c: \"PlanarConfiguration\",\r\n        0x0212: \"YCbCrSubSampling\",\r\n        0x0213: \"YCbCrPositioning\",\r\n        0x011a: \"XResolution\",\r\n        0x011b: \"YResolution\",\r\n        0x0128: \"ResolutionUnit\",\r\n        0x0111: \"StripOffsets\",\r\n        0x0116: \"RowsPerStrip\",\r\n        0x0117: \"StripByteCounts\",\r\n        0x0201: \"JPEGInterchangeFormat\",\r\n        0x0202: \"JPEGInterchangeFormatLength\",\r\n        0x012d: \"TransferFunction\",\r\n        0x013e: \"WhitePoint\",\r\n        0x013f: \"PrimaryChromaticities\",\r\n        0x0211: \"YCbCrCoefficients\",\r\n        0x0214: \"ReferenceBlackWhite\",\r\n        0x0132: \"DateTime\",\r\n        0x010e: \"ImageDescription\",\r\n        0x010f: \"Make\",\r\n        0x0110: \"Model\",\r\n        0x0131: \"Software\",\r\n        0x013b: \"Artist\",\r\n        0x8298: \"Copyright\"\r\n    };\r\n    Exif.GPSTags = {\r\n        0x0000: \"GPSVersionID\",\r\n        0x0001: \"GPSLatitudeRef\",\r\n        0x0002: \"GPSLatitude\",\r\n        0x0003: \"GPSLongitudeRef\",\r\n        0x0004: \"GPSLongitude\",\r\n        0x0005: \"GPSAltitudeRef\",\r\n        0x0006: \"GPSAltitude\",\r\n        0x0007: \"GPSTimeStamp\",\r\n        0x0008: \"GPSSatellites\",\r\n        0x0009: \"GPSStatus\",\r\n        0x000a: \"GPSMeasureMode\",\r\n        0x000b: \"GPSDOP\",\r\n        0x000c: \"GPSSpeedRef\",\r\n        0x000d: \"GPSSpeed\",\r\n        0x000e: \"GPSTrackRef\",\r\n        0x000f: \"GPSTrack\",\r\n        0x0010: \"GPSImgDirectionRef\",\r\n        0x0011: \"GPSImgDirection\",\r\n        0x0012: \"GPSMapDatum\",\r\n        0x0013: \"GPSDestLatitudeRef\",\r\n        0x0014: \"GPSDestLatitude\",\r\n        0x0015: \"GPSDestLongitudeRef\",\r\n        0x0016: \"GPSDestLongitude\",\r\n        0x0017: \"GPSDestBearingRef\",\r\n        0x0018: \"GPSDestBearing\",\r\n        0x0019: \"GPSDestDistanceRef\",\r\n        0x001a: \"GPSDestDistance\",\r\n        0x001b: \"GPSProcessingMethod\",\r\n        0x001c: \"GPSAreaInformation\",\r\n        0x001d: \"GPSDateStamp\",\r\n        0x001e: \"GPSDifferential\"\r\n    };\r\n    Exif.StringValues = {\r\n        ExposureProgram: {\r\n            0: \"Not defined\",\r\n            1: \"Manual\",\r\n            2: \"Normal program\",\r\n            3: \"Aperture priority\",\r\n            4: \"Shutter priority\",\r\n            5: \"Creative program\",\r\n            6: \"Action program\",\r\n            7: \"Portrait mode\",\r\n            8: \"Landscape mode\"\r\n        },\r\n        MeteringMode: {\r\n            0: \"Unknown\",\r\n            1: \"Average\",\r\n            2: \"CenterWeightedAverage\",\r\n            3: \"Spot\",\r\n            4: \"MultiSpot\",\r\n            5: \"Pattern\",\r\n            6: \"Partial\",\r\n            255: \"Other\"\r\n        },\r\n        LightSource: {\r\n            0: \"Unknown\",\r\n            1: \"Daylight\",\r\n            2: \"Fluorescent\",\r\n            3: \"Tungsten (incandescent light)\",\r\n            4: \"Flash\",\r\n            9: \"Fine weather\",\r\n            10: \"Cloudy weather\",\r\n            11: \"Shade\",\r\n            12: \"Daylight fluorescent (D 5700 - 7100K)\",\r\n            13: \"Day white fluorescent (N 4600 - 5400K)\",\r\n            14: \"Cool white fluorescent (W 3900 - 4500K)\",\r\n            15: \"White fluorescent (WW 3200 - 3700K)\",\r\n            17: \"Standard light A\",\r\n            18: \"Standard light B\",\r\n            19: \"Standard light C\",\r\n            20: \"D55\",\r\n            21: \"D65\",\r\n            22: \"D75\",\r\n            23: \"D50\",\r\n            24: \"ISO studio tungsten\",\r\n            255: \"Other\"\r\n        },\r\n        Flash: {\r\n            0x0000: \"Flash did not fire\",\r\n            0x0001: \"Flash fired\",\r\n            0x0005: \"Strobe return light not detected\",\r\n            0x0007: \"Strobe return light detected\",\r\n            0x0009: \"Flash fired, compulsory flash mode\",\r\n            0x000d: \"Flash fired, compulsory flash mode, return light not detected\",\r\n            0x000f: \"Flash fired, compulsory flash mode, return light detected\",\r\n            0x0010: \"Flash did not fire, compulsory flash mode\",\r\n            0x0018: \"Flash did not fire, auto mode\",\r\n            0x0019: \"Flash fired, auto mode\",\r\n            0x001d: \"Flash fired, auto mode, return light not detected\",\r\n            0x001f: \"Flash fired, auto mode, return light detected\",\r\n            0x0020: \"No flash function\",\r\n            0x0041: \"Flash fired, red-eye reduction mode\",\r\n            0x0045: \"Flash fired, red-eye reduction mode, return light not detected\",\r\n            0x0047: \"Flash fired, red-eye reduction mode, return light detected\",\r\n            0x0049: \"Flash fired, compulsory flash mode, red-eye reduction mode\",\r\n            0x004d: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\r\n            0x004f: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\r\n            0x0059: \"Flash fired, auto mode, red-eye reduction mode\",\r\n            0x005d: \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\r\n            0x005f: \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\r\n        },\r\n        SensingMethod: {\r\n            1: \"Not defined\",\r\n            2: \"One-chip color area sensor\",\r\n            3: \"Two-chip color area sensor\",\r\n            4: \"Three-chip color area sensor\",\r\n            5: \"Color sequential area sensor\",\r\n            7: \"Trilinear sensor\",\r\n            8: \"Color sequential linear sensor\"\r\n        },\r\n        SceneCaptureType: {\r\n            0: \"Standard\",\r\n            1: \"Landscape\",\r\n            2: \"Portrait\",\r\n            3: \"Night scene\"\r\n        },\r\n        SceneType: {\r\n            1: \"Directly photographed\"\r\n        },\r\n        CustomRendered: {\r\n            0: \"Normal process\",\r\n            1: \"Custom process\"\r\n        },\r\n        WhiteBalance: {\r\n            0: \"Auto white balance\",\r\n            1: \"Manual white balance\"\r\n        },\r\n        GainControl: {\r\n            0: \"None\",\r\n            1: \"Low gain up\",\r\n            2: \"High gain up\",\r\n            3: \"Low gain down\",\r\n            4: \"High gain down\"\r\n        },\r\n        Contrast: {\r\n            0: \"Normal\",\r\n            1: \"Soft\",\r\n            2: \"Hard\"\r\n        },\r\n        Saturation: {\r\n            0: \"Normal\",\r\n            1: \"Low saturation\",\r\n            2: \"High saturation\"\r\n        },\r\n        Sharpness: {\r\n            0: \"Normal\",\r\n            1: \"Soft\",\r\n            2: \"Hard\"\r\n        },\r\n        SubjectDistanceRange: {\r\n            0: \"Unknown\",\r\n            1: \"Macro\",\r\n            2: \"Close view\",\r\n            3: \"Distant view\"\r\n        },\r\n        FileSource: {\r\n            3: \"DSC\"\r\n        },\r\n        Components: {\r\n            0: \"\",\r\n            1: \"Y\",\r\n            2: \"Cb\",\r\n            3: \"Cr\",\r\n            4: \"R\",\r\n            5: \"G\",\r\n            6: \"B\"\r\n        }\r\n    };\r\n    return Exif;\r\n}());\r\nexport { Exif };\r\n//# sourceMappingURL=exif.js.map","var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Bounds } from './model/bounds';\r\nimport { CornerMarker } from './model/cornerMarker';\r\nimport { CropTouch } from './model/cropTouch';\r\nimport { DragMarker } from './model/dragMarker';\r\nimport { ImageCropperModel } from './model/imageCropperModel';\r\nimport { ImageCropperDataShare } from './imageCropperDataShare';\r\nimport { PointPool } from './model/pointPool';\r\nvar ImageCropper = /** @class */ (function (_super) {\r\n    __extends(ImageCropper, _super);\r\n    function ImageCropper(cropperSettings) {\r\n        var _this = _super.call(this) || this;\r\n        var x = 0;\r\n        var y = 0;\r\n        var width = cropperSettings.width;\r\n        var height = cropperSettings.height;\r\n        var keepAspect = cropperSettings.keepAspect;\r\n        var touchRadius = cropperSettings.touchRadius;\r\n        var centerTouchRadius = cropperSettings.centerTouchRadius;\r\n        var minWidth = cropperSettings.minWidth;\r\n        var minHeight = cropperSettings.minHeight;\r\n        var croppedWidth = cropperSettings.croppedWidth;\r\n        var croppedHeight = cropperSettings.croppedHeight;\r\n        _this.cropperSettings = cropperSettings;\r\n        _this.crop = _this;\r\n        _this.x = x;\r\n        _this.y = y;\r\n        _this.canvasHeight = cropperSettings.canvasHeight;\r\n        _this.canvasWidth = cropperSettings.canvasWidth;\r\n        _this.width = width;\r\n        if (width === void 0) {\r\n            _this.width = 100;\r\n        }\r\n        _this.height = height;\r\n        if (height === void 0) {\r\n            _this.height = 50;\r\n        }\r\n        _this.keepAspect = keepAspect;\r\n        if (keepAspect === void 0) {\r\n            _this.keepAspect = true;\r\n        }\r\n        _this.touchRadius = touchRadius;\r\n        if (touchRadius === void 0) {\r\n            _this.touchRadius = 20;\r\n        }\r\n        _this.minWidth = minWidth;\r\n        _this.minHeight = minHeight;\r\n        _this.aspectRatio = 0;\r\n        _this.currentDragTouches = [];\r\n        _this.isMouseDown = false;\r\n        _this.ratioW = 1;\r\n        _this.ratioH = 1;\r\n        _this.fileType = cropperSettings.fileType;\r\n        _this.imageSet = false;\r\n        _this.pointPool = new PointPool(200);\r\n        _this.tl = new CornerMarker(x, y, touchRadius, _this.cropperSettings);\r\n        _this.tr = new CornerMarker(x + width, y, touchRadius, _this.cropperSettings);\r\n        _this.bl = new CornerMarker(x, y + height, touchRadius, _this.cropperSettings);\r\n        _this.br = new CornerMarker(x + width, y + height, touchRadius, _this.cropperSettings);\r\n        _this.tl.addHorizontalNeighbour(_this.tr);\r\n        _this.tl.addVerticalNeighbour(_this.bl);\r\n        _this.tr.addHorizontalNeighbour(_this.tl);\r\n        _this.tr.addVerticalNeighbour(_this.br);\r\n        _this.bl.addHorizontalNeighbour(_this.br);\r\n        _this.bl.addVerticalNeighbour(_this.tl);\r\n        _this.br.addHorizontalNeighbour(_this.bl);\r\n        _this.br.addVerticalNeighbour(_this.tr);\r\n        _this.markers = [_this.tl, _this.tr, _this.bl, _this.br];\r\n        _this.center = new DragMarker(x + (width / 2), y + (height / 2), centerTouchRadius, _this.cropperSettings);\r\n        _this.aspectRatio = height / width;\r\n        _this.croppedImage = new Image();\r\n        _this.currentlyInteracting = false;\r\n        _this.cropWidth = croppedWidth;\r\n        _this.cropHeight = croppedHeight;\r\n        return _this;\r\n    }\r\n    ImageCropper.sign = function (x) {\r\n        if (+x === x) {\r\n            return (x === 0) ? x : (x > 0) ? 1 : -1;\r\n        }\r\n        return NaN;\r\n    };\r\n    ImageCropper.getMousePos = function (canvas, evt) {\r\n        var rect = canvas.getBoundingClientRect();\r\n        return PointPool.instance.borrow(evt.clientX - rect.left, evt.clientY - rect.top);\r\n    };\r\n    ImageCropper.getTouchPos = function (canvas, touch) {\r\n        var rect = canvas.getBoundingClientRect();\r\n        return PointPool.instance.borrow(touch.clientX - rect.left, touch.clientY - rect.top);\r\n    };\r\n    ImageCropper.detectVerticalSquash = function (img) {\r\n        var ih = img.height;\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = 1;\r\n        canvas.height = ih;\r\n        var ctx = canvas.getContext('2d');\r\n        ctx.drawImage(img, 0, 0);\r\n        var imageData = ctx.getImageData(0, 0, 1, ih);\r\n        if (imageData) {\r\n            var data = imageData.data;\r\n            // search image edge pixel position in case it is squashed vertically.\r\n            var sy = 0;\r\n            var ey = ih;\r\n            var py = ih;\r\n            while (py > sy) {\r\n                var alpha = data[(py - 1) * 4 + 3];\r\n                if (alpha === 0) {\r\n                    ey = py;\r\n                }\r\n                else {\r\n                    sy = py;\r\n                }\r\n                py = (ey + sy) >> 1;\r\n            }\r\n            var ratio = (py / ih);\r\n            return (ratio === 0) ? 1 : ratio;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    };\r\n    ImageCropper.prototype.getDataUriMimeType = function (dataUri) {\r\n        // Get a substring because the regex does not perform well on very large strings. Cater for optional charset. Length 50 shoould be enough.\r\n        var dataUriSubstring = dataUri.substring(0, 50);\r\n        var mimeType = 'image/png';\r\n        // data-uri scheme\r\n        // data:[<media type>][;charset=<character set>][;base64],<data>\r\n        var regEx = RegExp(/^(data:)([\\w\\/\\+]+);(charset=[\\w-]+|base64).*,(.*)/gi);\r\n        var matches = regEx.exec(dataUriSubstring);\r\n        if (matches && matches[2]) {\r\n            mimeType = matches[2];\r\n            if (mimeType == 'image/jpg') {\r\n                mimeType = 'image/jpeg';\r\n            }\r\n        }\r\n        return mimeType;\r\n    };\r\n    ImageCropper.prototype.prepare = function (canvas) {\r\n        this.buffer = document.createElement('canvas');\r\n        this.cropCanvas = document.createElement('canvas');\r\n        // todo get more reliable parent width value.\r\n        var responsiveWidth = canvas.parentElement ? canvas.parentElement.clientWidth : 0;\r\n        if (responsiveWidth > 0 && this.cropperSettings.dynamicSizing) {\r\n            this.cropCanvas.width = responsiveWidth;\r\n            this.buffer.width = responsiveWidth;\r\n            canvas.width = responsiveWidth;\r\n        }\r\n        else {\r\n            this.cropCanvas.width = this.cropWidth;\r\n            this.buffer.width = canvas.width;\r\n        }\r\n        this.cropCanvas.height = this.cropHeight;\r\n        this.buffer.height = canvas.height;\r\n        this.canvas = canvas;\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.draw(this.ctx);\r\n    };\r\n    ImageCropper.prototype.updateSettings = function (cropperSettings) {\r\n        this.cropperSettings = cropperSettings;\r\n    };\r\n    ImageCropper.prototype.resizeCanvas = function (width, height, setImage) {\r\n        if (setImage === void 0) { setImage = false; }\r\n        this.canvas.width = this.cropCanvas.width = this.width = this.canvasWidth = this.buffer.width = width;\r\n        this.canvas.height = this.cropCanvas.height = this.height = this.canvasHeight = this.buffer.height = height;\r\n        if (setImage) {\r\n            this.setImage(this.srcImage);\r\n        }\r\n    };\r\n    ImageCropper.prototype.reset = function () {\r\n        this.setImage(undefined);\r\n    };\r\n    ImageCropper.prototype.draw = function (ctx) {\r\n        var bounds = this.getBounds();\r\n        if (this.srcImage) {\r\n            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n            var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n            var canvasAspect = this.canvasHeight / this.canvasWidth;\r\n            var w = this.canvasWidth;\r\n            var h = this.canvasHeight;\r\n            if (canvasAspect > sourceAspect) {\r\n                w = this.canvasWidth;\r\n                h = this.canvasWidth * sourceAspect;\r\n            }\r\n            else {\r\n                h = this.canvasHeight;\r\n                w = this.canvasHeight / sourceAspect;\r\n            }\r\n            this.ratioW = w / this.srcImage.width;\r\n            this.ratioH = h / this.srcImage.height;\r\n            if (canvasAspect < sourceAspect) {\r\n                this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, this.buffer.width / 2 - w / 2, 0, w, h);\r\n            }\r\n            else {\r\n                this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, 0, this.buffer.height / 2 - h / 2, w, h);\r\n            }\r\n            this.buffer.getContext('2d')\r\n                .drawImage(this.canvas, 0, 0, this.canvasWidth, this.canvasHeight);\r\n            ctx.lineWidth = this.cropperSettings.cropperDrawSettings.strokeWidth;\r\n            ctx.strokeStyle = this.cropperSettings.cropperDrawSettings.strokeColor; // 'rgba(255,228,0,1)';\r\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\r\n            if (!this.cropperSettings.rounded) {\r\n                ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n                ctx.drawImage(this.buffer, bounds.left, bounds.top, Math.max(bounds.width, 1), Math.max(bounds.height, 1), bounds.left, bounds.top, bounds.width, bounds.height);\r\n                ctx.strokeRect(bounds.left, bounds.top, bounds.width, bounds.height);\r\n            }\r\n            else {\r\n                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n                ctx.save();\r\n                ctx.beginPath();\r\n                ctx.arc(bounds.left + bounds.width / 2, bounds.top + bounds.height / 2, bounds.width / 2, 0, 2 * Math.PI);\r\n                ctx.clip();\r\n                if (canvasAspect < sourceAspect) {\r\n                    this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, this.buffer.width / 2 - w / 2, 0, w, h);\r\n                }\r\n                else {\r\n                    this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, 0, this.buffer.height / 2 - h / 2, w, h);\r\n                }\r\n                ctx.restore();\r\n            }\r\n            var marker = void 0;\r\n            for (var i = 0; i < this.markers.length; i++) {\r\n                marker = this.markers[i];\r\n                marker.draw(ctx);\r\n            }\r\n            this.center.draw(ctx);\r\n        }\r\n        else {\r\n            ctx.fillStyle = 'rgba(192,192,192,1)';\r\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        }\r\n    };\r\n    ImageCropper.prototype.dragCenter = function (x, y, marker) {\r\n        var bounds = this.getBounds();\r\n        var left = x - (bounds.width / 2);\r\n        var right = x + (bounds.width / 2);\r\n        var top = y - (bounds.height / 2);\r\n        var bottom = y + (bounds.height / 2);\r\n        if (right >= this.maxXClamp) {\r\n            x = this.maxXClamp - bounds.width / 2;\r\n        }\r\n        if (left <= this.minXClamp) {\r\n            x = bounds.width / 2 + this.minXClamp;\r\n        }\r\n        if (top < this.minYClamp) {\r\n            y = bounds.height / 2 + this.minYClamp;\r\n        }\r\n        if (bottom >= this.maxYClamp) {\r\n            y = this.maxYClamp - bounds.height / 2;\r\n        }\r\n        this.tl.moveX(x - (bounds.width / 2));\r\n        this.tl.moveY(y - (bounds.height / 2));\r\n        this.tr.moveX(x + (bounds.width / 2));\r\n        this.tr.moveY(y - (bounds.height / 2));\r\n        this.bl.moveX(x - (bounds.width / 2));\r\n        this.bl.moveY(y + (bounds.height / 2));\r\n        this.br.moveX(x + (bounds.width / 2));\r\n        this.br.moveY(y + (bounds.height / 2));\r\n        marker.setPosition(x, y);\r\n    };\r\n    ImageCropper.prototype.enforceMinSize = function (x, y, marker) {\r\n        var xLength = x - marker.getHorizontalNeighbour().position.x;\r\n        var yLength = y - marker.getVerticalNeighbour().position.y;\r\n        var xOver = this.minWidth - Math.abs(xLength);\r\n        var yOver = this.minHeight - Math.abs(yLength);\r\n        if (xLength === 0 || yLength === 0) {\r\n            x = marker.position.x;\r\n            y = marker.position.y;\r\n            return PointPool.instance.borrow(x, y);\r\n        }\r\n        if (this.keepAspect) {\r\n            if (xOver > 0 && (yOver / this.aspectRatio) > 0) {\r\n                if (xOver > (yOver / this.aspectRatio)) {\r\n                    if (xLength < 0) {\r\n                        x -= xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                    else {\r\n                        x += xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (yLength < 0) {\r\n                        y -= yOver;\r\n                        if (xLength < 0) {\r\n                            x -= yOver / this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            x += yOver / this.aspectRatio;\r\n                        }\r\n                    }\r\n                    else {\r\n                        y += yOver;\r\n                        if (xLength < 0) {\r\n                            x -= yOver / this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            x += yOver / this.aspectRatio;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (xOver > 0) {\r\n                    if (xLength < 0) {\r\n                        x -= xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                    else {\r\n                        x += xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (yOver > 0) {\r\n                        if (yLength < 0) {\r\n                            y -= yOver;\r\n                            if (xLength < 0) {\r\n                                x -= yOver / this.aspectRatio;\r\n                            }\r\n                            else {\r\n                                x += yOver / this.aspectRatio;\r\n                            }\r\n                        }\r\n                        else {\r\n                            y += yOver;\r\n                            if (xLength < 0) {\r\n                                x -= yOver / this.aspectRatio;\r\n                            }\r\n                            else {\r\n                                x += yOver / this.aspectRatio;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (xOver > 0) {\r\n                if (xLength < 0) {\r\n                    x -= xOver;\r\n                }\r\n                else {\r\n                    x += xOver;\r\n                }\r\n            }\r\n            if (yOver > 0) {\r\n                if (yLength < 0) {\r\n                    y -= yOver;\r\n                }\r\n                else {\r\n                    y += yOver;\r\n                }\r\n            }\r\n        }\r\n        if (x < this.minXClamp || x > this.maxXClamp || y < this.minYClamp || y > this.maxYClamp) {\r\n            x = marker.position.x;\r\n            y = marker.position.y;\r\n        }\r\n        return PointPool.instance.borrow(x, y);\r\n    };\r\n    ImageCropper.prototype.dragCorner = function (x, y, marker) {\r\n        var iX = 0;\r\n        var iY = 0;\r\n        var ax = 0;\r\n        var ay = 0;\r\n        var newHeight = 0;\r\n        var newWidth = 0;\r\n        var newY = 0;\r\n        var newX = 0;\r\n        var anchorMarker;\r\n        var fold = 0;\r\n        if (this.keepAspect) {\r\n            anchorMarker = marker.getHorizontalNeighbour().getVerticalNeighbour();\r\n            ax = anchorMarker.position.x;\r\n            ay = anchorMarker.position.y;\r\n            if (x <= anchorMarker.position.x) {\r\n                if (y <= anchorMarker.position.y) {\r\n                    iX = ax - (100 / this.aspectRatio);\r\n                    iY = ay - (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold > 0) {\r\n                        newHeight = Math.abs(anchorMarker.position.y - y);\r\n                        newWidth = newHeight / this.aspectRatio;\r\n                        newY = anchorMarker.position.y - newHeight;\r\n                        newX = anchorMarker.position.x - newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold < 0) {\r\n                            newWidth = Math.abs(anchorMarker.position.x - x);\r\n                            newHeight = newWidth * this.aspectRatio;\r\n                            newY = anchorMarker.position.y - newHeight;\r\n                            newX = anchorMarker.position.x - newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    iX = ax - (100 / this.aspectRatio);\r\n                    iY = ay + (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold > 0) {\r\n                        newWidth = Math.abs(anchorMarker.position.x - x);\r\n                        newHeight = newWidth * this.aspectRatio;\r\n                        newY = anchorMarker.position.y + newHeight;\r\n                        newX = anchorMarker.position.x - newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold < 0) {\r\n                            newHeight = Math.abs(anchorMarker.position.y - y);\r\n                            newWidth = newHeight / this.aspectRatio;\r\n                            newY = anchorMarker.position.y + newHeight;\r\n                            newX = anchorMarker.position.x - newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (y <= anchorMarker.position.y) {\r\n                    iX = ax + (100 / this.aspectRatio);\r\n                    iY = ay - (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold < 0) {\r\n                        newHeight = Math.abs(anchorMarker.position.y - y);\r\n                        newWidth = newHeight / this.aspectRatio;\r\n                        newY = anchorMarker.position.y - newHeight;\r\n                        newX = anchorMarker.position.x + newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold > 0) {\r\n                            newWidth = Math.abs(anchorMarker.position.x - x);\r\n                            newHeight = newWidth * this.aspectRatio;\r\n                            newY = anchorMarker.position.y - newHeight;\r\n                            newX = anchorMarker.position.x + newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    iX = ax + (100 / this.aspectRatio);\r\n                    iY = ay + (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold < 0) {\r\n                        newWidth = Math.abs(anchorMarker.position.x - x);\r\n                        newHeight = newWidth * this.aspectRatio;\r\n                        newY = anchorMarker.position.y + newHeight;\r\n                        newX = anchorMarker.position.x + newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold > 0) {\r\n                            newHeight = Math.abs(anchorMarker.position.y - y);\r\n                            newWidth = newHeight / this.aspectRatio;\r\n                            newY = anchorMarker.position.y + newHeight;\r\n                            newX = anchorMarker.position.x + newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var min = this.enforceMinSize(x, y, marker);\r\n            marker.move(min.x, min.y);\r\n            PointPool.instance.returnPoint(min);\r\n        }\r\n        this.center.recalculatePosition(this.getBounds());\r\n    };\r\n    ImageCropper.prototype.getSide = function (a, b, c) {\r\n        var n = ImageCropper.sign((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));\r\n        // TODO move the return of the pools to outside of this function\r\n        PointPool.instance.returnPoint(a);\r\n        PointPool.instance.returnPoint(c);\r\n        return n;\r\n    };\r\n    ImageCropper.prototype.handleRelease = function (newCropTouch) {\r\n        if (newCropTouch == null) {\r\n            return;\r\n        }\r\n        var index = 0;\r\n        for (var k = 0; k < this.currentDragTouches.length; k++) {\r\n            if (newCropTouch.id === this.currentDragTouches[k].id) {\r\n                this.currentDragTouches[k].dragHandle.setDrag(false);\r\n                index = k;\r\n            }\r\n        }\r\n        this.currentDragTouches.splice(index, 1);\r\n        this.draw(this.ctx);\r\n    };\r\n    ImageCropper.prototype.handleMove = function (newCropTouch) {\r\n        var matched = false;\r\n        for (var k = 0; k < this.currentDragTouches.length; k++) {\r\n            if (newCropTouch.id === this.currentDragTouches[k].id && this.currentDragTouches[k].dragHandle != null) {\r\n                var dragTouch = this.currentDragTouches[k];\r\n                var clampedPositions = this.clampPosition(newCropTouch.x - dragTouch.dragHandle.offset.x, newCropTouch.y - dragTouch.dragHandle.offset.y);\r\n                newCropTouch.x = clampedPositions.x;\r\n                newCropTouch.y = clampedPositions.y;\r\n                PointPool.instance.returnPoint(clampedPositions);\r\n                if (dragTouch.dragHandle instanceof CornerMarker) {\r\n                    this.dragCorner(newCropTouch.x, newCropTouch.y, dragTouch.dragHandle);\r\n                }\r\n                else {\r\n                    this.dragCenter(newCropTouch.x, newCropTouch.y, dragTouch.dragHandle);\r\n                }\r\n                this.currentlyInteracting = true;\r\n                matched = true;\r\n                ImageCropperDataShare.setPressed(this.canvas);\r\n                break;\r\n            }\r\n        }\r\n        if (!matched) {\r\n            for (var i = 0; i < this.markers.length; i++) {\r\n                var marker = this.markers[i];\r\n                if (marker.touchInBounds(newCropTouch.x, newCropTouch.y)) {\r\n                    newCropTouch.dragHandle = marker;\r\n                    this.currentDragTouches.push(newCropTouch);\r\n                    marker.setDrag(true);\r\n                    newCropTouch.dragHandle.offset.x = newCropTouch.x - newCropTouch.dragHandle.position.x;\r\n                    newCropTouch.dragHandle.offset.y = newCropTouch.y - newCropTouch.dragHandle.position.y;\r\n                    this.dragCorner(newCropTouch.x - newCropTouch.dragHandle.offset.x, newCropTouch.y - newCropTouch.dragHandle.offset.y, newCropTouch.dragHandle);\r\n                    break;\r\n                }\r\n            }\r\n            if (newCropTouch.dragHandle === null || typeof newCropTouch.dragHandle === 'undefined') {\r\n                if (this.center.touchInBounds(newCropTouch.x, newCropTouch.y)) {\r\n                    newCropTouch.dragHandle = this.center;\r\n                    this.currentDragTouches.push(newCropTouch);\r\n                    newCropTouch.dragHandle.setDrag(true);\r\n                    newCropTouch.dragHandle.offset.x = newCropTouch.x - newCropTouch.dragHandle.position.x;\r\n                    newCropTouch.dragHandle.offset.y = newCropTouch.y - newCropTouch.dragHandle.position.y;\r\n                    this.dragCenter(newCropTouch.x - newCropTouch.dragHandle.offset.x, newCropTouch.y - newCropTouch.dragHandle.offset.y, newCropTouch.dragHandle);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    ImageCropper.prototype.updateClampBounds = function () {\r\n        var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n        var canvasAspect = this.canvas.height / this.canvas.width;\r\n        var w = this.canvas.width;\r\n        var h = this.canvas.height;\r\n        if (canvasAspect > sourceAspect) {\r\n            w = this.canvas.width;\r\n            h = this.canvas.width * sourceAspect;\r\n        }\r\n        else {\r\n            h = this.canvas.height;\r\n            w = this.canvas.height / sourceAspect;\r\n        }\r\n        this.minXClamp = this.canvas.width / 2 - w / 2;\r\n        this.minYClamp = this.canvas.height / 2 - h / 2;\r\n        this.maxXClamp = this.canvas.width / 2 + w / 2;\r\n        this.maxYClamp = this.canvas.height / 2 + h / 2;\r\n    };\r\n    ImageCropper.prototype.getCropBounds = function () {\r\n        var bounds = this.getBounds();\r\n        bounds.top = Math.round((bounds.top - this.minYClamp) / this.ratioH);\r\n        bounds.bottom = Math.round((bounds.bottom - this.minYClamp) / this.ratioH);\r\n        bounds.left = Math.round((bounds.left - this.minXClamp) / this.ratioW);\r\n        bounds.right = Math.round((bounds.right - this.minXClamp) / this.ratioW);\r\n        return bounds;\r\n    };\r\n    ImageCropper.prototype.clampPosition = function (x, y) {\r\n        if (x < this.minXClamp) {\r\n            x = this.minXClamp;\r\n        }\r\n        if (x > this.maxXClamp) {\r\n            x = this.maxXClamp;\r\n        }\r\n        if (y < this.minYClamp) {\r\n            y = this.minYClamp;\r\n        }\r\n        if (y > this.maxYClamp) {\r\n            y = this.maxYClamp;\r\n        }\r\n        return PointPool.instance.borrow(x, y);\r\n    };\r\n    ImageCropper.prototype.isImageSet = function () {\r\n        return this.imageSet;\r\n    };\r\n    ImageCropper.prototype.setImage = function (img) {\r\n        this.srcImage = img;\r\n        if (!img) {\r\n            this.imageSet = false;\r\n            this.draw(this.ctx);\r\n        }\r\n        else {\r\n            this.imageSet = true;\r\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n            var bufferContext = this.buffer.getContext('2d');\r\n            bufferContext.clearRect(0, 0, this.buffer.width, this.buffer.height);\r\n            if (!this.cropperSettings.fileType)\r\n                this.fileType = this.getDataUriMimeType(img.src);\r\n            if (this.cropperSettings.minWithRelativeToResolution) {\r\n                this.minWidth = (this.canvas.width * this.cropperSettings.minWidth / this.srcImage.width);\r\n                this.minHeight = (this.canvas.height * this.cropperSettings.minHeight / this.srcImage.height);\r\n            }\r\n            this.updateClampBounds();\r\n            this.canvasWidth = this.canvas.width;\r\n            this.canvasHeight = this.canvas.height;\r\n            var cropPosition = this.getCropPositionFromMarkers();\r\n            this.setCropPosition(cropPosition);\r\n        }\r\n    };\r\n    ImageCropper.prototype.updateCropPosition = function (cropBounds) {\r\n        var cropPosition = this.getCropPositionFromBounds(cropBounds);\r\n        this.setCropPosition(cropPosition);\r\n    };\r\n    ImageCropper.prototype.setCropPosition = function (cropPosition) {\r\n        this.tl.setPosition(cropPosition[0].x, cropPosition[0].y);\r\n        this.tr.setPosition(cropPosition[1].x, cropPosition[1].y);\r\n        this.bl.setPosition(cropPosition[2].x, cropPosition[2].y);\r\n        this.br.setPosition(cropPosition[3].x, cropPosition[3].y);\r\n        this.center.setPosition(cropPosition[4].x, cropPosition[4].y);\r\n        for (var _i = 0, cropPosition_1 = cropPosition; _i < cropPosition_1.length; _i++) {\r\n            var position = cropPosition_1[_i];\r\n            PointPool.instance.returnPoint(position);\r\n        }\r\n        this.vertSquashRatio = ImageCropper.detectVerticalSquash(this.srcImage);\r\n        this.draw(this.ctx);\r\n        this.croppedImage = this.getCroppedImageHelper(false, this.cropWidth, this.cropHeight);\r\n    };\r\n    ImageCropper.prototype.getCropPositionFromMarkers = function () {\r\n        var w = this.canvas.width;\r\n        var h = this.canvas.height;\r\n        var tlPos, trPos, blPos, brPos, center;\r\n        var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n        var cropBounds = this.getBounds();\r\n        var cropAspect = cropBounds.height / cropBounds.width;\r\n        var cX = this.canvas.width / 2;\r\n        var cY = this.canvas.height / 2;\r\n        if (cropAspect > sourceAspect) {\r\n            var imageH = Math.min(w * sourceAspect, h);\r\n            var cropW = imageH / cropAspect;\r\n            tlPos = PointPool.instance.borrow(cX - cropW / 2, cY + imageH / 2);\r\n            trPos = PointPool.instance.borrow(cX + cropW / 2, cY + imageH / 2);\r\n            blPos = PointPool.instance.borrow(cX - cropW / 2, cY - imageH / 2);\r\n            brPos = PointPool.instance.borrow(cX + cropW / 2, cY - imageH / 2);\r\n        }\r\n        else {\r\n            var imageW = Math.min(h / sourceAspect, w);\r\n            var cropH = imageW * cropAspect;\r\n            tlPos = PointPool.instance.borrow(cX - imageW / 2, cY + cropH / 2);\r\n            trPos = PointPool.instance.borrow(cX + imageW / 2, cY + cropH / 2);\r\n            blPos = PointPool.instance.borrow(cX - imageW / 2, cY - cropH / 2);\r\n            brPos = PointPool.instance.borrow(cX + imageW / 2, cY - cropH / 2);\r\n        }\r\n        center = PointPool.instance.borrow(cX, cY);\r\n        var positions = [tlPos, trPos, blPos, brPos, center];\r\n        return positions;\r\n    };\r\n    ImageCropper.prototype.getCropPositionFromBounds = function (cropPosition) {\r\n        var marginTop = 0;\r\n        var marginLeft = 0;\r\n        var canvasAspect = this.canvasHeight / this.canvasWidth;\r\n        var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n        if (canvasAspect > sourceAspect) {\r\n            marginTop = this.buffer.height / 2 - (this.canvasWidth * sourceAspect) / 2;\r\n        }\r\n        else {\r\n            marginLeft = this.buffer.width / 2 - (this.canvasHeight / sourceAspect) / 2;\r\n        }\r\n        var ratioW = (this.canvasWidth - marginLeft * 2) / this.srcImage.width;\r\n        var ratioH = (this.canvasHeight - marginTop * 2) / this.srcImage.height;\r\n        var actualH = cropPosition.height * ratioH;\r\n        var actualW = cropPosition.width * ratioW;\r\n        var actualX = cropPosition.left * ratioW + marginLeft;\r\n        var actualY = cropPosition.top * ratioH + marginTop;\r\n        if (this.keepAspect) {\r\n            var scaledW = actualH / this.aspectRatio;\r\n            var scaledH = actualW * this.aspectRatio;\r\n            if (this.getCropBounds().height === cropPosition.height) { // only width changed\r\n                actualH = scaledH;\r\n            }\r\n            else if (this.getCropBounds().width === cropPosition.width) { // only height changed\r\n                actualW = scaledW;\r\n            }\r\n            else { // height and width changed\r\n                if (Math.abs(scaledH - actualH) < Math.abs(scaledW - actualW)) {\r\n                    actualW = scaledW;\r\n                }\r\n                else {\r\n                    actualH = scaledH;\r\n                }\r\n            }\r\n        }\r\n        var tlPos = PointPool.instance.borrow(actualX, actualY + actualH);\r\n        var trPos = PointPool.instance.borrow(actualX + actualW, actualY + actualH);\r\n        var blPos = PointPool.instance.borrow(actualX, actualY);\r\n        var brPos = PointPool.instance.borrow(actualX + actualW, actualY);\r\n        var center = PointPool.instance.borrow(actualX + actualW / 2, actualY + actualH / 2);\r\n        var positions = [tlPos, trPos, blPos, brPos, center];\r\n        return positions;\r\n    };\r\n    ImageCropper.prototype.getCroppedImageHelper = function (preserveSize, fillWidth, fillHeight) {\r\n        if (this.cropperSettings.cropOnResize) {\r\n            return this.getCroppedImage(preserveSize, fillWidth, fillHeight);\r\n        }\r\n        return this.croppedImage ? this.croppedImage : document.createElement('img');\r\n    };\r\n    // todo: Unused parameters?\r\n    ImageCropper.prototype.getCroppedImage = function (preserveSize, fillWidth, fillHeight) {\r\n        var bounds = this.getBounds();\r\n        if (!this.srcImage) {\r\n            return document.createElement('img');\r\n        }\r\n        else {\r\n            var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n            var canvasAspect = this.canvas.height / this.canvas.width;\r\n            var w = this.canvas.width;\r\n            var h = this.canvas.height;\r\n            if (canvasAspect > sourceAspect) {\r\n                w = this.canvas.width;\r\n                h = this.canvas.width * sourceAspect;\r\n            }\r\n            else {\r\n                if (canvasAspect < sourceAspect) {\r\n                    h = this.canvas.height;\r\n                    w = this.canvas.height / sourceAspect;\r\n                }\r\n                else {\r\n                    h = this.canvas.height;\r\n                    w = this.canvas.width;\r\n                }\r\n            }\r\n            this.ratioW = w / this.srcImage.width;\r\n            this.ratioH = h / this.srcImage.height;\r\n            var offsetH = (this.buffer.height - h) / 2 / this.ratioH;\r\n            var offsetW = (this.buffer.width - w) / 2 / this.ratioW;\r\n            var ctx = this.cropCanvas.getContext('2d');\r\n            if (this.cropperSettings.preserveSize || preserveSize) {\r\n                var width = Math.round(bounds.right / this.ratioW - bounds.left / this.ratioW);\r\n                var height = Math.round(bounds.bottom / this.ratioH - bounds.top / this.ratioH);\r\n                this.cropCanvas.width = width;\r\n                this.cropCanvas.height = height;\r\n                this.cropperSettings.croppedWidth = this.cropCanvas.width;\r\n                this.cropperSettings.croppedHeight = this.cropCanvas.height;\r\n            }\r\n            else {\r\n                this.cropCanvas.width = this.cropWidth;\r\n                this.cropCanvas.height = this.cropHeight;\r\n            }\r\n            ctx.clearRect(0, 0, this.cropCanvas.width, this.cropCanvas.height);\r\n            this.drawImageIOSFix(ctx, this.srcImage, Math.max(Math.round((bounds.left) / this.ratioW - offsetW), 0), Math.max(Math.round(bounds.top / this.ratioH - offsetH), 0), Math.max(Math.round(bounds.width / this.ratioW), 1), Math.max(Math.round(bounds.height / this.ratioH), 1), 0, 0, this.cropCanvas.width, this.cropCanvas.height);\r\n            if (this.cropperSettings.resampleFn) {\r\n                this.cropperSettings.resampleFn(this.cropCanvas);\r\n            }\r\n            this.croppedImage.width = this.cropCanvas.width;\r\n            this.croppedImage.height = this.cropCanvas.height;\r\n            this.croppedImage.src = this.cropCanvas.toDataURL(this.fileType, this.cropperSettings.compressRatio);\r\n            return this.croppedImage;\r\n        }\r\n    };\r\n    ImageCropper.prototype.getBounds = function () {\r\n        var minX = Number.MAX_VALUE;\r\n        var minY = Number.MAX_VALUE;\r\n        var maxX = -Number.MAX_VALUE;\r\n        var maxY = -Number.MAX_VALUE;\r\n        for (var i = 0; i < this.markers.length; i++) {\r\n            var marker = this.markers[i];\r\n            if (marker.position.x < minX) {\r\n                minX = marker.position.x;\r\n            }\r\n            if (marker.position.x > maxX) {\r\n                maxX = marker.position.x;\r\n            }\r\n            if (marker.position.y < minY) {\r\n                minY = marker.position.y;\r\n            }\r\n            if (marker.position.y > maxY) {\r\n                maxY = marker.position.y;\r\n            }\r\n        }\r\n        var bounds = new Bounds();\r\n        bounds.left = minX;\r\n        bounds.right = maxX;\r\n        bounds.top = minY;\r\n        bounds.bottom = maxY;\r\n        return bounds;\r\n    };\r\n    ImageCropper.prototype.setBounds = function (bounds) {\r\n        var topLeft;\r\n        var topRight;\r\n        var bottomLeft;\r\n        var bottomRight;\r\n        var currentBounds = this.getBounds();\r\n        for (var i = 0; i < this.markers.length; i++) {\r\n            var marker = this.markers[i];\r\n            if (marker.position.x === currentBounds.left) {\r\n                if (marker.position.y === currentBounds.top) {\r\n                    marker.setPosition(bounds.left, bounds.top);\r\n                }\r\n                else {\r\n                    marker.setPosition(bounds.left, bounds.bottom);\r\n                }\r\n            }\r\n            else {\r\n                if (marker.position.y === currentBounds.top) {\r\n                    marker.setPosition(bounds.right, bounds.top);\r\n                }\r\n                else {\r\n                    marker.setPosition(bounds.right, bounds.bottom);\r\n                }\r\n            }\r\n        }\r\n        this.center.recalculatePosition(bounds);\r\n        this.center.draw(this.ctx);\r\n        this.draw(this.ctx); // we need to redraw all canvas if we have changed bounds\r\n    };\r\n    ImageCropper.prototype.onTouchMove = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            if (event.touches.length === 1) {\r\n                if (this.isMouseDown) {\r\n                    event.preventDefault();\r\n                    for (var i = 0; i < event.touches.length; i++) {\r\n                        var touch = event.touches[i];\r\n                        var touchPosition = ImageCropper.getTouchPos(this.canvas, touch);\r\n                        var cropTouch = new CropTouch(touchPosition.x, touchPosition.y, touch.identifier);\r\n                        PointPool.instance.returnPoint(touchPosition);\r\n                        this.move(cropTouch);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (event.touches.length === 2) {\r\n                    event.preventDefault();\r\n                    var distance = ((event.touches[0].clientX - event.touches[1].clientX) * (event.touches[0].clientX - event.touches[1].clientX)) + ((event.touches[0].clientY - event.touches[1].clientY) * (event.touches[0].clientY - event.touches[1].clientY));\r\n                    if (this.previousDistance && this.previousDistance !== distance) {\r\n                        var bounds = this.getBounds();\r\n                        if (distance < this.previousDistance) {\r\n                            bounds.top += 1;\r\n                            bounds.left += 1;\r\n                            bounds.right -= 1;\r\n                            bounds.bottom -= 1;\r\n                        }\r\n                        if (distance > this.previousDistance) {\r\n                            if (bounds.top !== this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right !== this.maxXClamp) { // none\r\n                                bounds.top -= 1;\r\n                                bounds.left -= 1;\r\n                                bounds.right += 1;\r\n                                bounds.bottom += 1;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left === this.minXClamp && bounds.right !== this.maxXClamp) { // left\r\n                                bounds.top -= 1;\r\n                                bounds.right += 2;\r\n                                bounds.bottom += 1;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right === this.maxXClamp) { // right\r\n                                bounds.top -= 1;\r\n                                bounds.left -= 2;\r\n                                bounds.bottom += 1;\r\n                            }\r\n                            else if (bounds.top === this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right !== this.maxXClamp) { // top\r\n                                bounds.left -= 1;\r\n                                bounds.right += 1;\r\n                                bounds.bottom += 2;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom === this.maxYClamp && bounds.left !== this.minXClamp && bounds.right !== this.maxXClamp) { // bottom\r\n                                bounds.top -= 2;\r\n                                bounds.left -= 1;\r\n                                bounds.right += 1;\r\n                            }\r\n                            else if (bounds.top === this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left === this.minXClamp && bounds.right !== this.maxXClamp) { // top left\r\n                                bounds.right += 2;\r\n                                bounds.bottom += 2;\r\n                            }\r\n                            else if (bounds.top === this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right === this.maxXClamp) { // top right\r\n                                bounds.left -= 2;\r\n                                bounds.bottom += 2;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom === this.maxYClamp && bounds.left === this.minXClamp && bounds.right !== this.maxXClamp) { // bottom left\r\n                                bounds.top -= 2;\r\n                                bounds.right += 2;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom === this.maxYClamp && bounds.left !== this.minXClamp && bounds.right === this.maxXClamp) { // bottom right\r\n                                bounds.top -= 2;\r\n                                bounds.left -= 2;\r\n                            }\r\n                        }\r\n                        if (bounds.top < this.minYClamp)\r\n                            bounds.top = this.minYClamp;\r\n                        if (bounds.bottom > this.maxYClamp)\r\n                            bounds.bottom = this.maxYClamp;\r\n                        if (bounds.left < this.minXClamp)\r\n                            bounds.left = this.minXClamp;\r\n                        if (bounds.right > this.maxXClamp)\r\n                            bounds.right = this.maxXClamp;\r\n                        this.setBounds(bounds);\r\n                    }\r\n                    this.previousDistance = distance;\r\n                }\r\n            }\r\n            this.draw(this.ctx);\r\n        }\r\n    };\r\n    ImageCropper.prototype.onMouseMove = function (e) {\r\n        if (this.crop.isImageSet() && this.isMouseDown) {\r\n            var mousePosition = ImageCropper.getMousePos(this.canvas, e);\r\n            this.move(new CropTouch(mousePosition.x, mousePosition.y, 0));\r\n            var dragTouch = this.getDragTouchForID(0);\r\n            if (dragTouch) {\r\n                dragTouch.x = mousePosition.x;\r\n                dragTouch.y = mousePosition.y;\r\n            }\r\n            else {\r\n                dragTouch = new CropTouch(mousePosition.x, mousePosition.y, 0);\r\n            }\r\n            PointPool.instance.returnPoint(mousePosition);\r\n            this.drawCursors(dragTouch);\r\n            this.draw(this.ctx);\r\n        }\r\n    };\r\n    ImageCropper.prototype.move = function (cropTouch) {\r\n        if (this.isMouseDown) {\r\n            this.handleMove(cropTouch);\r\n        }\r\n    };\r\n    ImageCropper.prototype.getDragTouchForID = function (id) {\r\n        for (var i = 0; i < this.currentDragTouches.length; i++) {\r\n            if (id === this.currentDragTouches[i].id) {\r\n                return this.currentDragTouches[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    ImageCropper.prototype.drawCursors = function (cropTouch) {\r\n        var cursorDrawn = false;\r\n        if (cropTouch != null) {\r\n            if (cropTouch.dragHandle === this.center) {\r\n                ImageCropperDataShare.setStyle(this.canvas, 'move');\r\n                cursorDrawn = true;\r\n            }\r\n            if (cropTouch.dragHandle !== null && cropTouch.dragHandle instanceof CornerMarker) {\r\n                this.drawCornerCursor(cropTouch.dragHandle, cropTouch.dragHandle.position.x, cropTouch.dragHandle.position.y);\r\n                cursorDrawn = true;\r\n            }\r\n        }\r\n        var didDraw = false;\r\n        if (!cursorDrawn) {\r\n            for (var i = 0; i < this.markers.length; i++) {\r\n                didDraw = didDraw || this.drawCornerCursor(this.markers[i], cropTouch.x, cropTouch.y);\r\n            }\r\n            if (!didDraw) {\r\n                ImageCropperDataShare.setStyle(this.canvas, 'initial');\r\n            }\r\n        }\r\n        if (!didDraw && !cursorDrawn && this.center.touchInBounds(cropTouch.x, cropTouch.y)) {\r\n            this.center.setOver(true);\r\n            ImageCropperDataShare.setOver(this.canvas);\r\n            ImageCropperDataShare.setStyle(this.canvas, 'move');\r\n        }\r\n        else {\r\n            this.center.setOver(false);\r\n        }\r\n    };\r\n    ImageCropper.prototype.drawCornerCursor = function (marker, x, y) {\r\n        if (marker.touchInBounds(x, y)) {\r\n            marker.setOver(true);\r\n            if (marker.getHorizontalNeighbour().position.x > marker.position.x) {\r\n                if (marker.getVerticalNeighbour().position.y > marker.position.y) {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nwse-resize');\r\n                }\r\n                else {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nesw-resize');\r\n                }\r\n            }\r\n            else {\r\n                if (marker.getVerticalNeighbour().position.y > marker.position.y) {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nesw-resize');\r\n                }\r\n                else {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nwse-resize');\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        marker.setOver(false);\r\n        return false;\r\n    };\r\n    ImageCropper.prototype.onTouchStart = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            var touch = event.touches[0];\r\n            var touchPosition = ImageCropper.getTouchPos(this.canvas, touch);\r\n            var cropTouch = new CropTouch(touchPosition.x, touchPosition.y, touch.identifier);\r\n            PointPool.instance.returnPoint(touchPosition);\r\n            this.isMouseDown = false;\r\n            for (var i = 0; i < this.markers.length; i++) {\r\n                var marker = this.markers[i];\r\n                if (marker.touchInBounds(cropTouch.x, cropTouch.y)) {\r\n                    this.isMouseDown = true;\r\n                }\r\n            }\r\n            if (this.center.touchInBounds(cropTouch.x, cropTouch.y)) {\r\n                this.isMouseDown = true;\r\n            }\r\n        }\r\n    };\r\n    ImageCropper.prototype.onTouchEnd = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            for (var i = 0; i < event.changedTouches.length; i++) {\r\n                var touch = event.changedTouches[i];\r\n                var dragTouch = this.getDragTouchForID(touch.identifier);\r\n                if (dragTouch && dragTouch !== undefined) {\r\n                    if (dragTouch.dragHandle instanceof CornerMarker || dragTouch.dragHandle instanceof DragMarker) {\r\n                        dragTouch.dragHandle.setOver(false);\r\n                    }\r\n                    this.handleRelease(dragTouch);\r\n                }\r\n            }\r\n            if (this.currentDragTouches.length === 0) {\r\n                this.isMouseDown = false;\r\n                this.currentlyInteracting = false;\r\n            }\r\n        }\r\n    };\r\n    // http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\r\n    ImageCropper.prototype.drawImageIOSFix = function (ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\r\n        // Works only if whole image is displayed:\r\n        // ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\r\n        // The following works correct also when only a part of the image is displayed:\r\n        // ctx.drawImage(img, sx * this.vertSquashRatio, sy * this.vertSquashRatio, sw * this.vertSquashRatio, sh *\r\n        // this.vertSquashRatio, dx, dy, dw, dh);\r\n        ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);\r\n    };\r\n    ImageCropper.prototype.onMouseDown = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            this.isMouseDown = true;\r\n        }\r\n    };\r\n    ImageCropper.prototype.onMouseUp = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            ImageCropperDataShare.setReleased(this.canvas);\r\n            this.isMouseDown = false;\r\n            this.handleRelease(new CropTouch(0, 0, 0));\r\n        }\r\n    };\r\n    return ImageCropper;\r\n}(ImageCropperModel));\r\nexport { ImageCropper };\r\n//# sourceMappingURL=imageCropper.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nimport { Component, Input, Renderer2, ViewChild, ElementRef, Output, EventEmitter } from \"@angular/core\";\r\nimport { ImageCropper } from \"./imageCropper\";\r\nimport { CropperSettings } from \"./cropperSettings\";\r\nimport { Exif } from \"./exif\";\r\nimport { CropPosition } from \"./model/cropPosition\";\r\nvar ImageCropperComponent = /** @class */ (function () {\r\n    function ImageCropperComponent(renderer) {\r\n        this.cropPositionChange = new EventEmitter();\r\n        this.onCrop = new EventEmitter();\r\n        this.imageSet = new EventEmitter();\r\n        this.renderer = renderer;\r\n    }\r\n    ImageCropperComponent.prototype.ngAfterViewInit = function () {\r\n        var canvas = this.cropcanvas.nativeElement;\r\n        if (!this.settings) {\r\n            this.settings = new CropperSettings();\r\n        }\r\n        if (this.settings.cropperClass) {\r\n            this.renderer.setAttribute(canvas, \"class\", this.settings.cropperClass);\r\n        }\r\n        if (!this.settings.dynamicSizing) {\r\n            this.renderer.setAttribute(canvas, \"width\", this.settings.canvasWidth.toString());\r\n            this.renderer.setAttribute(canvas, \"height\", this.settings.canvasHeight.toString());\r\n        }\r\n        else {\r\n            this.windowListener = this.resize.bind(this);\r\n            window.addEventListener(\"resize\", this.windowListener);\r\n        }\r\n        if (!this.cropper) {\r\n            this.cropper = new ImageCropper(this.settings);\r\n        }\r\n        this.cropper.prepare(canvas);\r\n    };\r\n    ImageCropperComponent.prototype.ngOnChanges = function (changes) {\r\n        if (this.isCropPositionChanged(changes)) {\r\n            this.cropper.updateCropPosition(this.cropPosition.toBounds());\r\n            if (this.cropper.isImageSet()) {\r\n                var bounds = this.cropper.getCropBounds();\r\n                this.image.image = this.cropper.getCroppedImageHelper().src;\r\n                this.onCrop.emit(bounds);\r\n            }\r\n            this.updateCropBounds();\r\n        }\r\n        if (changes.inputImage) {\r\n            this.setImage(changes.inputImage.currentValue);\r\n        }\r\n        if (changes.settings && this.cropper) {\r\n            this.cropper.updateSettings(this.settings);\r\n            if (this.cropper.isImageSet()) {\r\n                this.image.image = this.cropper.getCroppedImageHelper().src;\r\n                this.onCrop.emit(this.cropper.getCropBounds());\r\n            }\r\n        }\r\n    };\r\n    ImageCropperComponent.prototype.ngOnDestroy = function () {\r\n        if (this.settings.dynamicSizing && this.windowListener) {\r\n            window.removeEventListener(\"resize\", this.windowListener);\r\n        }\r\n    };\r\n    ImageCropperComponent.prototype.onTouchMove = function (event) {\r\n        this.cropper.onTouchMove(event);\r\n    };\r\n    ImageCropperComponent.prototype.onTouchStart = function (event) {\r\n        this.cropper.onTouchStart(event);\r\n    };\r\n    ImageCropperComponent.prototype.onTouchEnd = function (event) {\r\n        this.cropper.onTouchEnd(event);\r\n        if (this.cropper.isImageSet()) {\r\n            this.image.image = this.cropper.getCroppedImageHelper().src;\r\n            this.onCrop.emit(this.cropper.getCropBounds());\r\n            this.updateCropBounds();\r\n        }\r\n    };\r\n    ImageCropperComponent.prototype.onMouseDown = function (event) {\r\n        this.cropper.onMouseDown(event);\r\n        // if (!this.cropper.isImageSet() && !this.settings.noFileInput) {\r\n        //   // load img\r\n        //   this.fileInput.nativeElement.click();\r\n        // }\r\n    };\r\n    ImageCropperComponent.prototype.onMouseUp = function (event) {\r\n        if (this.cropper.isImageSet()) {\r\n            this.cropper.onMouseUp(event);\r\n            this.image.image = this.cropper.getCroppedImageHelper().src;\r\n            this.onCrop.emit(this.cropper.getCropBounds());\r\n            this.updateCropBounds();\r\n        }\r\n    };\r\n    ImageCropperComponent.prototype.onMouseMove = function (event) {\r\n        this.cropper.onMouseMove(event);\r\n    };\r\n    ImageCropperComponent.prototype.fileChangeListener = function ($event) {\r\n        var _this = this;\r\n        if ($event.target.files.length === 0)\r\n            return;\r\n        var file = $event.target.files[0];\r\n        if (this.settings.allowedFilesRegex.test(file.name)) {\r\n            var image_1 = new Image();\r\n            var fileReader = new FileReader();\r\n            fileReader.addEventListener(\"loadend\", function (loadEvent) {\r\n                image_1.addEventListener(\"load\", function () {\r\n                    _this.setImage(image_1);\r\n                });\r\n                image_1.src = loadEvent.target.result;\r\n            });\r\n            fileReader.readAsDataURL(file);\r\n        }\r\n    };\r\n    ImageCropperComponent.prototype.resize = function () {\r\n        var canvas = this.cropcanvas.nativeElement;\r\n        this.settings.canvasWidth = canvas.offsetWidth;\r\n        this.settings.canvasHeight = canvas.offsetHeight;\r\n        this.cropper.resizeCanvas(canvas.offsetWidth, canvas.offsetHeight, true);\r\n    };\r\n    ImageCropperComponent.prototype.reset = function () {\r\n        this.cropper.reset();\r\n        this.renderer.setAttribute(this.cropcanvas.nativeElement, \"class\", this.settings.cropperClass);\r\n        this.image.image = this.cropper.getCroppedImageHelper().src;\r\n    };\r\n    ImageCropperComponent.prototype.setImage = function (image, newBounds) {\r\n        var _this = this;\r\n        if (newBounds === void 0) { newBounds = null; }\r\n        this.imageSet.emit(true);\r\n        this.renderer.setAttribute(this.cropcanvas.nativeElement, \"class\", this.settings.cropperClass + \" \" + this.settings.croppingClass);\r\n        this.raf = window.requestAnimationFrame(function () {\r\n            if (_this.raf) {\r\n                window.cancelAnimationFrame(_this.raf);\r\n            }\r\n            if (image.naturalHeight > 0 && image.naturalWidth > 0) {\r\n                image.height = image.naturalHeight;\r\n                image.width = image.naturalWidth;\r\n                window.cancelAnimationFrame(_this.raf);\r\n                _this.getOrientedImage(image, function (img) {\r\n                    if (_this.settings.dynamicSizing) {\r\n                        var canvas = _this.cropcanvas.nativeElement;\r\n                        _this.settings.canvasWidth = canvas.offsetWidth;\r\n                        _this.settings.canvasHeight = canvas.offsetHeight;\r\n                        _this.cropper.resizeCanvas(canvas.offsetWidth, canvas.offsetHeight, false);\r\n                    }\r\n                    _this.cropper.setImage(img);\r\n                    if (_this.cropPosition && _this.cropPosition.isInitialized()) {\r\n                        _this.cropper.updateCropPosition(_this.cropPosition.toBounds());\r\n                    }\r\n                    _this.image.original = img;\r\n                    var bounds = _this.cropper.getCropBounds();\r\n                    _this.image.image = _this.cropper.getCroppedImageHelper().src;\r\n                    if (!_this.image) {\r\n                        _this.image = image;\r\n                    }\r\n                    if (newBounds != null) {\r\n                        bounds = newBounds;\r\n                        _this.cropper.setBounds(bounds);\r\n                        _this.cropper.updateCropPosition(bounds);\r\n                    }\r\n                    _this.onCrop.emit(bounds);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    ImageCropperComponent.prototype.isCropPositionChanged = function (changes) {\r\n        if (this.cropper &&\r\n            changes[\"cropPosition\"] &&\r\n            this.isCropPositionUpdateNeeded) {\r\n            return true;\r\n        }\r\n        else {\r\n            this.isCropPositionUpdateNeeded = true;\r\n            return false;\r\n        }\r\n    };\r\n    ImageCropperComponent.prototype.updateCropBounds = function () {\r\n        var cropBound = this.cropper.getCropBounds();\r\n        this.cropPositionChange.emit(new CropPosition(cropBound.left, cropBound.top, cropBound.width, cropBound.height));\r\n        this.isCropPositionUpdateNeeded = false;\r\n    };\r\n    ImageCropperComponent.prototype.getOrientedImage = function (image, callback) {\r\n        var img;\r\n        Exif.getData(image, function () {\r\n            var orientation = Exif.getTag(image, \"Orientation\");\r\n            if ([3, 6, 8].indexOf(orientation) > -1) {\r\n                var canvas = document.createElement(\"canvas\"), ctx = canvas.getContext(\"2d\"), cw = image.width, ch = image.height, cx = 0, cy = 0, deg = 0;\r\n                switch (orientation) {\r\n                    case 3:\r\n                        cx = -image.width;\r\n                        cy = -image.height;\r\n                        deg = 180;\r\n                        break;\r\n                    case 6:\r\n                        cw = image.height;\r\n                        ch = image.width;\r\n                        cy = -image.height;\r\n                        deg = 90;\r\n                        break;\r\n                    case 8:\r\n                        cw = image.height;\r\n                        ch = image.width;\r\n                        cx = -image.width;\r\n                        deg = 270;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n                canvas.width = cw;\r\n                canvas.height = ch;\r\n                ctx.rotate(deg * Math.PI / 180);\r\n                ctx.drawImage(image, cx, cy);\r\n                img = document.createElement(\"img\");\r\n                img.width = cw;\r\n                img.height = ch;\r\n                img.addEventListener(\"load\", function () {\r\n                    callback(img);\r\n                });\r\n                img.src = canvas.toDataURL(\"image/png\");\r\n            }\r\n            else {\r\n                img = image;\r\n                callback(img);\r\n            }\r\n        });\r\n    };\r\n    __decorate([\r\n        ViewChild(\"cropcanvas\", undefined),\r\n        __metadata(\"design:type\", ElementRef)\r\n    ], ImageCropperComponent.prototype, \"cropcanvas\", void 0);\r\n    __decorate([\r\n        ViewChild(\"fileInput\"),\r\n        __metadata(\"design:type\", ElementRef)\r\n    ], ImageCropperComponent.prototype, \"fileInput\", void 0);\r\n    __decorate([\r\n        Input(\"settings\"),\r\n        __metadata(\"design:type\", CropperSettings)\r\n    ], ImageCropperComponent.prototype, \"settings\", void 0);\r\n    __decorate([\r\n        Input(\"image\"),\r\n        __metadata(\"design:type\", Object)\r\n    ], ImageCropperComponent.prototype, \"image\", void 0);\r\n    __decorate([\r\n        Input(\"inputImage\"),\r\n        __metadata(\"design:type\", Object)\r\n    ], ImageCropperComponent.prototype, \"inputImage\", void 0);\r\n    __decorate([\r\n        Input(),\r\n        __metadata(\"design:type\", ImageCropper)\r\n    ], ImageCropperComponent.prototype, \"cropper\", void 0);\r\n    __decorate([\r\n        Input(),\r\n        __metadata(\"design:type\", CropPosition)\r\n    ], ImageCropperComponent.prototype, \"cropPosition\", void 0);\r\n    __decorate([\r\n        Output(),\r\n        __metadata(\"design:type\", EventEmitter)\r\n    ], ImageCropperComponent.prototype, \"cropPositionChange\", void 0);\r\n    __decorate([\r\n        Output(),\r\n        __metadata(\"design:type\", EventEmitter)\r\n    ], ImageCropperComponent.prototype, \"onCrop\", void 0);\r\n    __decorate([\r\n        Output(),\r\n        __metadata(\"design:type\", EventEmitter)\r\n    ], ImageCropperComponent.prototype, \"imageSet\", void 0);\r\n    ImageCropperComponent = __decorate([\r\n        Component({\r\n            selector: \"img-cropper\",\r\n            template: \"\\n        <span class=\\\"ng2-imgcrop\\\">\\n          <input *ngIf=\\\"!settings.noFileInput\\\" #fileInput type=\\\"file\\\" accept=\\\"image/*\\\" (change)=\\\"fileChangeListener($event)\\\">\\n          <canvas #cropcanvas\\n                  (mousedown)=\\\"onMouseDown($event)\\\"\\n                  (mouseup)=\\\"onMouseUp($event)\\\"\\n                  (mousemove)=\\\"onMouseMove($event)\\\"\\n                  (mouseleave)=\\\"onMouseUp($event)\\\"\\n                  (touchmove)=\\\"onTouchMove($event)\\\"\\n                  (touchend)=\\\"onTouchEnd($event)\\\"\\n                  (touchstart)=\\\"onTouchStart($event)\\\">\\n          </canvas>\\n        </span>\\n      \"\r\n        }),\r\n        __metadata(\"design:paramtypes\", [Renderer2])\r\n    ], ImageCropperComponent);\r\n    return ImageCropperComponent;\r\n}());\r\nexport { ImageCropperComponent };\r\n//# sourceMappingURL=imageCropperComponent.js.map","var ImageCropperDataShare = /** @class */ (function () {\r\n    function ImageCropperDataShare() {\r\n    }\r\n    ImageCropperDataShare.setPressed = function (canvas) {\r\n        this.pressed = canvas;\r\n    };\r\n    ImageCropperDataShare.setReleased = function (canvas) {\r\n        if (canvas === this.pressed) {\r\n            //  this.pressed = undefined;\r\n        }\r\n    };\r\n    ImageCropperDataShare.setOver = function (canvas) {\r\n        this.over = canvas;\r\n    };\r\n    ImageCropperDataShare.setStyle = function (canvas, style) {\r\n        if (this.pressed !== undefined) {\r\n            if (this.pressed === canvas) {\r\n                // TODO: check this\r\n                // angular.element(document.documentElement).css('cursor', style);\r\n            }\r\n        }\r\n        else {\r\n            if (canvas === this.over) {\r\n                // TODO: check this\r\n                // angular.element(document.documentElement).css('cursor', style);\r\n            }\r\n        }\r\n    };\r\n    ImageCropperDataShare.share = {};\r\n    return ImageCropperDataShare;\r\n}());\r\nexport { ImageCropperDataShare };\r\n//# sourceMappingURL=imageCropperDataShare.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nimport { CommonModule } from \"@angular/common\";\r\nimport { NgModule } from \"@angular/core\";\r\nimport { ImageCropperComponent } from \"./imageCropperComponent\";\r\nvar ImageCropperModule = /** @class */ (function () {\r\n    function ImageCropperModule() {\r\n    }\r\n    ImageCropperModule = __decorate([\r\n        NgModule({\r\n            imports: [CommonModule],\r\n            declarations: [ImageCropperComponent],\r\n            exports: [ImageCropperComponent]\r\n        })\r\n    ], ImageCropperModule);\r\n    return ImageCropperModule;\r\n}());\r\nexport { ImageCropperModule };\r\n//# sourceMappingURL=imageCropperModule.js.map","import { PointPool } from \"./pointPool\";\r\nvar Bounds = /** @class */ (function () {\r\n    function Bounds(x, y, width, height) {\r\n        if (x === void 0) {\r\n            x = 0;\r\n        }\r\n        if (y === void 0) {\r\n            y = 0;\r\n        }\r\n        if (width === void 0) {\r\n            width = 0;\r\n        }\r\n        if (height === void 0) {\r\n            height = 0;\r\n        }\r\n        this.left = x;\r\n        this.right = x + width;\r\n        this.top = y;\r\n        this.bottom = y + height;\r\n    }\r\n    Object.defineProperty(Bounds.prototype, \"width\", {\r\n        get: function () {\r\n            return this.right - this.left;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bounds.prototype, \"height\", {\r\n        get: function () {\r\n            return this.bottom - this.top;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Bounds.prototype.getCentre = function () {\r\n        var w = this.width;\r\n        var h = this.height;\r\n        return PointPool.instance.borrow(this.left + w / 2, this.top + h / 2);\r\n    };\r\n    return Bounds;\r\n}());\r\nexport { Bounds };\r\n//# sourceMappingURL=bounds.js.map","var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Handle } from \"./handle\";\r\nvar CornerMarker = /** @class */ (function (_super) {\r\n    __extends(CornerMarker, _super);\r\n    function CornerMarker(x, y, radius, cropperSettings) {\r\n        return _super.call(this, x, y, radius, cropperSettings) || this;\r\n    }\r\n    CornerMarker.prototype.drawCornerBorder = function (ctx) {\r\n        var sideLength = 10;\r\n        if (this.over || this.drag) {\r\n            sideLength = 12;\r\n        }\r\n        var hDirection = this.cropperSettings.markerSizeMultiplier;\r\n        var vDirection = this.cropperSettings.markerSizeMultiplier;\r\n        if (this.horizontalNeighbour.position.x < this.position.x) {\r\n            hDirection = -this.cropperSettings.markerSizeMultiplier;\r\n        }\r\n        if (this.verticalNeighbour.position.y < this.position.y) {\r\n            vDirection = -this.cropperSettings.markerSizeMultiplier;\r\n        }\r\n        if (this.cropperSettings.rounded) {\r\n            var width = this.position.x - this.horizontalNeighbour.position.x;\r\n            var height = this.position.y - this.verticalNeighbour.position.y;\r\n            var offX = Math.round(Math.sin(Math.PI / 2) * Math.abs(width / 2)) / 4;\r\n            var offY = Math.round(Math.sin(Math.PI / 2) * Math.abs(height / 2)) / 4;\r\n            this.offset.x = hDirection > 0 ? offX : -offX;\r\n            this.offset.y = vDirection > 0 ? offY : -offY;\r\n        }\r\n        else {\r\n            this.offset.x = 0;\r\n            this.offset.y = 0;\r\n        }\r\n        ctx.beginPath();\r\n        if (this.cropperSettings.cropperDrawSettings.lineDash) {\r\n            ctx.setLineDash([1, 3]);\r\n        }\r\n        ctx.lineJoin = \"miter\";\r\n        ctx.moveTo(this.position.x + this.offset.x, this.position.y + this.offset.y);\r\n        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y);\r\n        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y + sideLength * vDirection);\r\n        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y + sideLength * vDirection);\r\n        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y);\r\n        ctx.closePath();\r\n        ctx.lineWidth = this.cropperSettings.cropperDrawSettings.strokeWidth;\r\n        ctx.strokeStyle =\r\n            this.cropperSettings.cropperDrawSettings.strokeColor ||\r\n                \"rgba(255,255,255,.7)\";\r\n        ctx.stroke();\r\n    };\r\n    CornerMarker.prototype.drawCornerFill = function (ctx) {\r\n        var sideLength = 10;\r\n        if (this.over || this.drag) {\r\n            sideLength = 12;\r\n        }\r\n        var hDirection = this.cropperSettings.markerSizeMultiplier;\r\n        var vDirection = this.cropperSettings.markerSizeMultiplier;\r\n        if (this.horizontalNeighbour.position.x < this.position.x) {\r\n            hDirection = -this.cropperSettings.markerSizeMultiplier;\r\n        }\r\n        if (this.verticalNeighbour.position.y < this.position.y) {\r\n            vDirection = -this.cropperSettings.markerSizeMultiplier;\r\n        }\r\n        ctx.beginPath();\r\n        if (this.cropperSettings.cropperDrawSettings.lineDash) {\r\n            ctx.setLineDash([1, 3]);\r\n        }\r\n        ctx.moveTo(this.position.x + this.offset.x, this.position.y + this.offset.y);\r\n        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y);\r\n        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y + sideLength * vDirection);\r\n        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y + sideLength * vDirection);\r\n        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y);\r\n        ctx.closePath();\r\n        ctx.fillStyle =\r\n            this.cropperSettings.cropperDrawSettings.strokeColor ||\r\n                \"rgba(255,255,255,.7)\";\r\n        ctx.fill();\r\n    };\r\n    CornerMarker.prototype.moveX = function (x) {\r\n        this.setPosition(x, this.position.y);\r\n    };\r\n    CornerMarker.prototype.moveY = function (y) {\r\n        this.setPosition(this.position.x, y);\r\n    };\r\n    CornerMarker.prototype.move = function (x, y) {\r\n        this.setPosition(x, y);\r\n        this.verticalNeighbour.moveX(x);\r\n        this.horizontalNeighbour.moveY(y);\r\n    };\r\n    CornerMarker.prototype.addHorizontalNeighbour = function (neighbour) {\r\n        this.horizontalNeighbour = neighbour;\r\n    };\r\n    CornerMarker.prototype.addVerticalNeighbour = function (neighbour) {\r\n        this.verticalNeighbour = neighbour;\r\n    };\r\n    CornerMarker.prototype.getHorizontalNeighbour = function () {\r\n        return this.horizontalNeighbour;\r\n    };\r\n    CornerMarker.prototype.getVerticalNeighbour = function () {\r\n        return this.verticalNeighbour;\r\n    };\r\n    CornerMarker.prototype.draw = function (ctx) {\r\n        this.drawCornerFill(ctx);\r\n        this.drawCornerBorder(ctx);\r\n    };\r\n    return CornerMarker;\r\n}(Handle));\r\nexport { CornerMarker };\r\n//# sourceMappingURL=cornerMarker.js.map","import { Bounds } from \"./bounds\";\r\nvar CropPosition = /** @class */ (function () {\r\n    function CropPosition(x, y, w, h) {\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        if (w === void 0) { w = 0; }\r\n        if (h === void 0) { h = 0; }\r\n        this.x = +x;\r\n        this.y = +y;\r\n        this.w = +w;\r\n        this.h = +h;\r\n    }\r\n    CropPosition.prototype.toBounds = function () {\r\n        return new Bounds(this.x, this.y, this.w, this.h);\r\n    };\r\n    CropPosition.prototype.isInitialized = function () {\r\n        return this.x !== 0 && this.y !== 0 && this.w !== 0 && this.h !== 0;\r\n    };\r\n    return CropPosition;\r\n}());\r\nexport { CropPosition };\r\n//# sourceMappingURL=cropPosition.js.map","var CropTouch = /** @class */ (function () {\r\n    function CropTouch(x, y, id) {\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        if (id === void 0) { id = 0; }\r\n        this.id = id;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    return CropTouch;\r\n}());\r\nexport { CropTouch };\r\n//# sourceMappingURL=cropTouch.js.map","var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Handle } from \"./handle\";\r\nimport { PointPool } from \"./pointPool\";\r\nvar DragMarker = /** @class */ (function (_super) {\r\n    __extends(DragMarker, _super);\r\n    function DragMarker(x, y, radius, cropperSettings) {\r\n        var _this = _super.call(this, x, y, radius, cropperSettings) || this;\r\n        _this.iconPoints = [];\r\n        _this.scaledIconPoints = [];\r\n        _this.getDragIconPoints(_this.iconPoints, 1);\r\n        _this.getDragIconPoints(_this.scaledIconPoints, 1.2);\r\n        return _this;\r\n    }\r\n    DragMarker.prototype.draw = function (ctx) {\r\n        if (this.over || this.drag) {\r\n            this.drawIcon(ctx, this.scaledIconPoints);\r\n        }\r\n        else {\r\n            this.drawIcon(ctx, this.iconPoints);\r\n        }\r\n    };\r\n    DragMarker.prototype.getDragIconPoints = function (arr, scale) {\r\n        var maxLength = 17 * scale;\r\n        var arrowWidth = 14 * scale;\r\n        var arrowLength = 8 * scale;\r\n        var connectorThroat = 4 * scale;\r\n        arr.push(PointPool.instance.borrow(-connectorThroat / 2, maxLength - arrowLength));\r\n        arr.push(PointPool.instance.borrow(-arrowWidth / 2, maxLength - arrowLength));\r\n        arr.push(PointPool.instance.borrow(0, maxLength));\r\n        arr.push(PointPool.instance.borrow(arrowWidth / 2, maxLength - arrowLength));\r\n        arr.push(PointPool.instance.borrow(connectorThroat / 2, maxLength - arrowLength));\r\n        arr.push(PointPool.instance.borrow(connectorThroat / 2, connectorThroat / 2));\r\n        arr.push(PointPool.instance.borrow(maxLength - arrowLength, connectorThroat / 2));\r\n        arr.push(PointPool.instance.borrow(maxLength - arrowLength, arrowWidth / 2));\r\n        arr.push(PointPool.instance.borrow(maxLength, 0));\r\n        arr.push(PointPool.instance.borrow(maxLength - arrowLength, -arrowWidth / 2));\r\n        arr.push(PointPool.instance.borrow(maxLength - arrowLength, -connectorThroat / 2));\r\n        arr.push(PointPool.instance.borrow(connectorThroat / 2, -connectorThroat / 2));\r\n        arr.push(PointPool.instance.borrow(connectorThroat / 2, -maxLength + arrowLength));\r\n        arr.push(PointPool.instance.borrow(arrowWidth / 2, -maxLength + arrowLength));\r\n        arr.push(PointPool.instance.borrow(0, -maxLength));\r\n        arr.push(PointPool.instance.borrow(-arrowWidth / 2, -maxLength + arrowLength));\r\n        arr.push(PointPool.instance.borrow(-connectorThroat / 2, -maxLength + arrowLength));\r\n        arr.push(PointPool.instance.borrow(-connectorThroat / 2, -connectorThroat / 2));\r\n        arr.push(PointPool.instance.borrow(-maxLength + arrowLength, -connectorThroat / 2));\r\n        arr.push(PointPool.instance.borrow(-maxLength + arrowLength, -arrowWidth / 2));\r\n        arr.push(PointPool.instance.borrow(-maxLength, 0));\r\n        arr.push(PointPool.instance.borrow(-maxLength + arrowLength, arrowWidth / 2));\r\n        arr.push(PointPool.instance.borrow(-maxLength + arrowLength, connectorThroat / 2));\r\n        arr.push(PointPool.instance.borrow(-connectorThroat / 2, connectorThroat / 2));\r\n    };\r\n    DragMarker.prototype.drawIcon = function (ctx, points) {\r\n        if (this.cropperSettings.showCenterMarker) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(points[0].x + this.position.x, points[0].y + this.position.y);\r\n            for (var k = 0; k < points.length; k++) {\r\n                var p = points[k];\r\n                ctx.lineTo(p.x + this.position.x, p.y + this.position.y);\r\n            }\r\n            ctx.closePath();\r\n            ctx.fillStyle = this.cropperSettings.cropperDrawSettings.dragIconFillColor;\r\n            ctx.fill();\r\n            ctx.lineWidth = this.cropperSettings.cropperDrawSettings.dragIconStrokeWidth;\r\n            ctx.strokeStyle = this.cropperSettings.cropperDrawSettings.dragIconStrokeColor;\r\n            ctx.stroke();\r\n        }\r\n    };\r\n    DragMarker.prototype.recalculatePosition = function (bounds) {\r\n        var c = bounds.getCentre();\r\n        this.setPosition(c.x, c.y);\r\n        PointPool.instance.returnPoint(c);\r\n    };\r\n    return DragMarker;\r\n}(Handle));\r\nexport { DragMarker };\r\n//# sourceMappingURL=dragMarker.js.map","import { Point } from \"./point\";\r\nimport { CropperSettings } from \"../cropperSettings\";\r\nvar Handle = /** @class */ (function () {\r\n    function Handle(x, y, radius, settings) {\r\n        this.cropperSettings = new CropperSettings();\r\n        this.over = false;\r\n        this.drag = false;\r\n        this._position = new Point(x, y);\r\n        this.offset = new Point(0, 0);\r\n        this.radius = radius;\r\n        this.cropperSettings = settings;\r\n    }\r\n    Handle.prototype.setDrag = function (value) {\r\n        this.drag = value;\r\n        this.setOver(value);\r\n    };\r\n    Handle.prototype.draw = function (ctx) {\r\n        // this should't be empty\r\n    };\r\n    Handle.prototype.setOver = function (over) {\r\n        this.over = over;\r\n    };\r\n    Handle.prototype.touchInBounds = function (x, y) {\r\n        return (x > this.position.x - this.radius + this.offset.x &&\r\n            x < this.position.x + this.radius + this.offset.x &&\r\n            y > this.position.y - this.radius + this.offset.y &&\r\n            y < this.position.y + this.radius + this.offset.y);\r\n    };\r\n    Object.defineProperty(Handle.prototype, \"position\", {\r\n        get: function () {\r\n            return this._position;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Handle.prototype.setPosition = function (x, y) {\r\n        this._position.x = x;\r\n        this._position.y = y;\r\n    };\r\n    return Handle;\r\n}());\r\nexport { Handle };\r\n//# sourceMappingURL=handle.js.map","var ImageCropperModel = /** @class */ (function () {\r\n    function ImageCropperModel() {\r\n    }\r\n    return ImageCropperModel;\r\n}());\r\nexport { ImageCropperModel };\r\n//# sourceMappingURL=imageCropperModel.js.map","var Point = /** @class */ (function () {\r\n    function Point(x, y) {\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    Object.defineProperty(Point.prototype, \"next\", {\r\n        get: function () {\r\n            return this._next;\r\n        },\r\n        set: function (p) {\r\n            this._next = p;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Point.prototype, \"prev\", {\r\n        get: function () {\r\n            return this._prev;\r\n        },\r\n        set: function (p) {\r\n            this._prev = p;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Point;\r\n}());\r\nexport { Point };\r\n//# sourceMappingURL=point.js.map","import { Point } from \"./point\";\r\nvar PointPool = /** @class */ (function () {\r\n    function PointPool(initialSize) {\r\n        PointPool._instance = this;\r\n        var prev = (this.firstAvailable = new Point());\r\n        for (var i = 1; i < initialSize; i++) {\r\n            var p = new Point();\r\n            prev.next = p;\r\n            prev = p;\r\n        }\r\n    }\r\n    Object.defineProperty(PointPool, \"instance\", {\r\n        get: function () {\r\n            return PointPool._instance;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    PointPool.prototype.borrow = function (x, y) {\r\n        if (this.firstAvailable == null) {\r\n            throw \"Pool exhausted\";\r\n        }\r\n        this.borrowed++;\r\n        var p = this.firstAvailable;\r\n        this.firstAvailable = p.next;\r\n        p.x = x;\r\n        p.y = y;\r\n        return p;\r\n    };\r\n    PointPool.prototype.returnPoint = function (p) {\r\n        this.borrowed--;\r\n        p.x = 0;\r\n        p.y = 0;\r\n        p.next = this.firstAvailable;\r\n        this.firstAvailable = p;\r\n    };\r\n    return PointPool;\r\n}());\r\nexport { PointPool };\r\n//# sourceMappingURL=pointPool.js.map","\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar core_1 = require('@angular/core');\nvar common_1 = require('@angular/common');\nvar owl_carousel_component_1 = require('./src/owl-carousel.component');\nvar owl_child_component_1 = require('./src/owl-child.component');\n__export(require('./src/owl-carousel.component'));\nvar OwlModule = (function () {\n    function OwlModule() {\n    }\n    OwlModule = __decorate([\n        core_1.NgModule({\n            imports: [\n                common_1.CommonModule\n            ],\n            declarations: [\n                owl_carousel_component_1.OwlCarousel, owl_child_component_1.OwlChild\n            ],\n            exports: [\n                owl_carousel_component_1.OwlCarousel\n            ]\n        }), \n        __metadata('design:paramtypes', [])\n    ], OwlModule);\n    return OwlModule;\n}());\nexports.OwlModule = OwlModule;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = require('@angular/core');\nvar owl_child_component_1 = require('./owl-child.component');\nvar OwlCarousel = (function () {\n    function OwlCarousel(differs) {\n        this.differs = differs;\n        this.carouselClasses = '';\n        this.options = {};\n    }\n    Object.defineProperty(OwlCarousel.prototype, \"items\", {\n        set: function (coll) {\n            this._items = coll;\n            if (coll && !this.differ) {\n                this.differ = this.differs.find(coll).create(null);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    OwlCarousel.prototype.ngDoCheck = function () {\n        if (this.differ) {\n            var changes = this.differ.diff(this._items);\n            if (changes) {\n                var changed_1 = false;\n                var changedFn = function () {\n                    changed_1 = true;\n                };\n                changes.forEachAddedItem(changedFn);\n                changes.forEachMovedItem(changedFn);\n                changes.forEachRemovedItem(changedFn);\n                if (changed_1) {\n                    this.reInit();\n                }\n            }\n        }\n    };\n    OwlCarousel.prototype.reInit = function () {\n        var _this = this;\n        if (this.$owlChild.$owl) {\n            this.$owlChild.$owl.css('display', 'none');\n        }\n        setTimeout(function () {\n            _this.$owlChild.destroyOwl();\n            if (_this.$owlChild.$owl) {\n                var itemLength = _this._items && _this._items.length;\n                if (itemLength && itemLength <= _this.$owlChild.currentSlideIndex) {\n                    _this.$owlChild.currentSlideIndex = itemLength;\n                }\n                _this.$owlChild.$owl.css('display', 'block');\n            }\n            _this.$owlChild.initOwl();\n        }, 0);\n    };\n    OwlCarousel.prototype.refresh = function () {\n        this.trigger('refresh.owl.carousel');\n    };\n    OwlCarousel.prototype.next = function (options) {\n        this.trigger('next.owl.carousel', options);\n    };\n    OwlCarousel.prototype.previous = function (options) {\n        this.trigger('prev.owl.carousel', options);\n    };\n    OwlCarousel.prototype.to = function (options) {\n        this.trigger('to.owl.carousel', options);\n    };\n    OwlCarousel.prototype.trigger = function (action, options) {\n        this.$owlChild.trigger(action, options);\n    };\n    __decorate([\n        core_1.ViewChild('owl'), \n        __metadata('design:type', owl_child_component_1.OwlChild)\n    ], OwlCarousel.prototype, \"$owlChild\", void 0);\n    __decorate([\n        core_1.Input(), \n        __metadata('design:type', Object)\n    ], OwlCarousel.prototype, \"carouselClasses\", void 0);\n    __decorate([\n        core_1.Input(), \n        __metadata('design:type', Object)\n    ], OwlCarousel.prototype, \"options\", void 0);\n    __decorate([\n        core_1.Input(), \n        __metadata('design:type', Array), \n        __metadata('design:paramtypes', [Array])\n    ], OwlCarousel.prototype, \"items\", null);\n    OwlCarousel = __decorate([\n        core_1.Component({\n            selector: 'owl-carousel',\n            template: '<owl-carousel-child #owl [ngClass]=\"carouselClasses\" [options]=\"options\" >' +\n                '<ng-content></ng-content></owl-carousel-child>',\n        }), \n        __metadata('design:paramtypes', [core_1.IterableDiffers])\n    ], OwlCarousel);\n    return OwlCarousel;\n}());\nexports.OwlCarousel = OwlCarousel;\n//# sourceMappingURL=owl-carousel.component.js.map","\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = require('@angular/core');\nvar OwlChild = (function () {\n    function OwlChild(el) {\n        this.el = el;\n        this.owlClass = true;\n        this.options = {};\n        if (typeof $ === 'undefined' && typeof jQuery !== 'undefined') {\n            $ = jQuery;\n        }\n    }\n    OwlChild.prototype.ngOnInit = function () {\n        if ((typeof window !== 'undefined') && $ && typeof $.fn.owlCarousel === 'function') {\n            this.$owl = $(this.el.nativeElement);\n        }\n    };\n    OwlChild.prototype.ngAfterViewInit = function () {\n        this.initOwl();\n    };\n    OwlChild.prototype.initOwl = function () {\n        var _this = this;\n        if (this.$owl) {\n            var options = {};\n            Object.assign(options, this.options);\n            if (this.currentSlideIndex) {\n                options.startPosition = this.currentSlideIndex;\n            }\n            this.$owl.owlCarousel(options);\n            this.$owl.on('changed.owl.carousel', function (event) {\n                _this.currentSlideIndex = event.item.index;\n            });\n        }\n    };\n    OwlChild.prototype.trigger = function (action, options) {\n        if (this.$owl) {\n            this.$owl.trigger(action, options);\n        }\n    };\n    OwlChild.prototype.ngOnDestroy = function () {\n        this.destroyOwl();\n        delete this.$owl;\n    };\n    OwlChild.prototype.destroyOwl = function () {\n        if (this.$owl) {\n            this.$owl.trigger('destroy.owl.carousel')\n                .removeClass('owl-loaded owl-hidden')\n                .find('.owl-stage:empty, .owl-item:empty')\n                .remove();\n        }\n    };\n    __decorate([\n        core_1.HostBinding('class.owl-carousel'), \n        __metadata('design:type', Object)\n    ], OwlChild.prototype, \"owlClass\", void 0);\n    __decorate([\n        core_1.Input(), \n        __metadata('design:type', Object)\n    ], OwlChild.prototype, \"options\", void 0);\n    OwlChild = __decorate([\n        core_1.Component({\n            selector: 'owl-carousel-child',\n            template: '<ng-content></ng-content>'\n        }), \n        __metadata('design:paramtypes', [core_1.ElementRef])\n    ], OwlChild);\n    return OwlChild;\n}());\nexports.OwlChild = OwlChild;\n//# sourceMappingURL=owl-child.component.js.map","/*****************************************************\n# Company Name          : \n# Author                : \n# Created Date          : 10-01-2019\n# Module                : AuthGuard                     \n# Object name           : AuthGuard    \n# Functionality         : middleware to check auth\n# Purpose               : constructor,canActivate\n*******************************************************/\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport {CommonService} from \"./services/common.service\";\nimport { Router } from '@angular/router';\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  /* Function Name : constructor\n  * Author : \n  * Created Date : 10-01-2019 \n  * Modified Date : *\n  * Purpose : to define the all helpful objects and define the languages data\n  * PARAMS : cService,router\n  */\n  constructor(private cService: CommonService, private router: Router) {}\n  \n  /* Function Name : canActivate\n  * Author : \n  * Created Date : 10-01-2019 \n  * Modified Date : *\n  * Purpose : to handel the auth\n  * PARAMS : next,state\n  */\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {\n\n    return this.cService.isLoggedIn().pipe(map((response: any) => {\n        if (response.status === 'success') {\n          return true;\n        } else {\n          this.router.navigate([\"\"]); // redirect to home page if not loggedin\n          return false;\n        }\n    }));\n    \n  }\n}\n"],"sourceRoot":""}