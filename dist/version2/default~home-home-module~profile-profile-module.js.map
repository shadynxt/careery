{"version":3,"sources":["webpack:///./node_modules/chart.piecelabel.js/src/Chart.PieceLabel.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,CAAC","file":"default~home-home-module~profile-profile-module.js","sourcesContent":["/**\n * [Chart.PieceLabel.js]{@link https://github.com/emn178/Chart.PieceLabel.js}\n *\n * @version 0.15.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2017-2018\n * @license MIT\n */\n(function () {\n  if (typeof Chart === 'undefined') {\n    console.warn('Can not find Chart object.');\n    return;\n  }\n\n  if (!Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  function PieceLabel() {\n    this.drawDataset = this.drawDataset.bind(this);\n  }\n\n  PieceLabel.prototype.beforeDatasetsUpdate = function (chartInstance, index) {\n    this.parseOptions(chartInstance, index);\n    if (this.position === 'outside') {\n      var padding = this.fontSize * 1.5 + this.outsidePadding;\n      chartInstance.chartArea.top += padding;\n      chartInstance.chartArea.bottom -= padding;\n    }\n  };\n\n  PieceLabel.prototype.afterDatasetsDraw = function (chartInstance, index) {\n    this.parseOptions(chartInstance, index);\n    this.labelBounds = [];\n    chartInstance.config.data.datasets.forEach(this.drawDataset);\n  };\n\n  PieceLabel.prototype.drawDataset = function (dataset) {\n    var ctx = this.ctx;\n    var chartInstance = this.chartInstance;\n    var meta = dataset._meta[Object.keys(dataset._meta)[0]];\n    this.totalPercentage = 0;\n    this.total = null;\n    for (var i = 0; i < meta.data.length; i++) {\n      var element = meta.data[i],\n        view = element._view, text;\n\n      if (!this.shouldRenderData(view)) {\n        continue;\n      }\n      switch (this.render) {\n        case 'value':\n          var value = dataset.data[i];\n          if (this.format) {\n            value = this.format(value);\n          }\n          text = value.toString();\n          break;\n        case 'label':\n          text = chartInstance.config.data.labels[i];\n          break;\n        case 'image':\n          text = this.images[i] ? this.loadImage(this.images[i]) : '';\n          break;\n        case 'percentage':\n        default:\n          percentage = this.getPercentage(view, dataset, i);\n          text = percentage + '%';\n          break;\n      }\n      if (typeof this.render === 'function') {\n        text = this.render({\n          label: chartInstance.config.data.labels[i],\n          value: dataset.data[i],\n          percentage: percentage,\n          dataset: dataset,\n          index: i\n        });\n\n        if (text === null || text === undefined) {\n          text = '';\n        } else if (typeof text === 'object') {\n          text = this.loadImage(text);\n        } else {\n          text = text.toString();\n        }\n      }\n      if (!text) {\n        continue;\n      }\n      ctx.save();\n      ctx.beginPath();\n      ctx.font = Chart.helpers.fontString(this.fontSize, this.fontStyle, this.fontFamily);\n      var position, innerRadius, arcOffset = 0;\n      if (this.position === 'outside' || this.position === 'border') {\n        innerRadius = view.outerRadius / 2;\n        var rangeFromCentre, offset = this.fontSize + this.textMargin,\n          centreAngle = view.startAngle + ((view.endAngle - view.startAngle) / 2);\n        if (this.position === 'border') {\n          rangeFromCentre = (view.outerRadius - innerRadius) / 2 + innerRadius;\n        } else if (this.position === 'outside') {\n          if (!this.arc) {\n            offset = this.textMargin;\n          }\n          rangeFromCentre = (view.outerRadius - innerRadius) + innerRadius + offset;\n        }\n        position = {\n          x: view.x + (Math.cos(centreAngle) * rangeFromCentre),\n          y: view.y + (Math.sin(centreAngle) * rangeFromCentre)\n        };\n        if (this.position === 'outside') {\n          if (!this.arc) {\n            offset += (this.measureText(text).width / 2);\n          }\n          if (position.x < view.x) {\n            position.x -= offset;\n          } else {\n            position.x += offset;\n          }\n          arcOffset = view.outerRadius + offset;\n        }\n      } else {\n        innerRadius = view.innerRadius;\n        position = element.tooltipPosition();\n      }\n\n      var fontColor = this.fontColor;\n      if (typeof fontColor === 'function') {\n        fontColor = fontColor({\n          label: chartInstance.config.data.labels[i],\n          value: dataset.data[i],\n          percentage: percentage,\n          text: text,\n          backgroundColor: dataset.backgroundColor[i],\n          dataset: dataset,\n          index: i\n        });\n      } else if (typeof fontColor !== 'string') {\n        fontColor = fontColor[i] || this.options.defaultFontColor;\n      }\n      if (this.arc) {\n        if (!arcOffset) {\n          arcOffset = (innerRadius + view.outerRadius) / 2;\n        }\n        ctx.fillStyle = fontColor;\n        ctx.textBaseline = 'middle';\n        this.drawArcText(text, arcOffset, view, this.overlap);\n      } else {\n        var drawable, mertrics = this.measureText(text),\n          left = position.x - mertrics.width / 2,\n          right = position.x + mertrics.width / 2,\n          top = position.y - mertrics.height / 2,\n          bottom = position.y + mertrics.height / 2;\n        if (this.overlap) {\n          drawable = true;\n        } else if (this.position === 'outside') {\n          drawable = this.checkTextBound(left, right, top, bottom);\n        } else {\n          drawable = element.inRange(left, top) && element.inRange(left, bottom) &&\n            element.inRange(right, top) && element.inRange(right, bottom);\n        }\n        if (drawable) {\n          this.fillText(text, position, fontColor);\n        }\n      }\n      ctx.restore();\n    }\n  };\n\n  PieceLabel.prototype.shouldRenderData = function (view) {\n    //Skips label creation if value is zero and showZero is set\n    return this.chartInstance.config.type === 'polarArea' ? view.outerRadius !== 0 : view.circumference !== 0 || this.showZero;\n  };\n\n  PieceLabel.prototype.getPercentage = function (view, dataset, index) {\n    var percentage;\n    if (this.chartInstance.config.type === 'polarArea') {\n      if (this.total === null) {\n        this.total = 0;\n        for (var i = 0;i < dataset.data.length; ++i) {\n          this.total += dataset.data[i];\n        }\n      }\n      percentage = dataset.data[index] / this.total * 100;\n    } else {\n      percentage = view.circumference / this.options.circumference * 100;\n    }\n    percentage = parseFloat(percentage.toFixed(this.precision));\n    if (!this.showActualPercentages) {\n      this.totalPercentage += percentage;\n      if (this.totalPercentage > 100) {\n        percentage -= this.totalPercentage - 100;\n        // After adjusting the percentage, need to trim the numbers after decimal points again, otherwise it may not show\n        // on chart due to very long number after decimal point.\n        percentage = parseFloat(percentage.toFixed(this.precision));\n      }\n    }\n    return percentage;\n  };\n\n  PieceLabel.prototype.parseOptions = function (chartInstance, index) {\n    var pieceLabel = chartInstance.options.pieceLabel;\n    if (Array.isArray(pieceLabel)) {\n      pieceLabel = pieceLabel[index];\n    }\n    this.chartInstance = chartInstance;\n    this.ctx = chartInstance.chart.ctx;\n    this.options = chartInstance.config.options;\n    this.render = pieceLabel.render || pieceLabel.mode;\n    this.position = pieceLabel.position || 'default';\n    this.arc = pieceLabel.arc;\n    this.format = pieceLabel.format;\n    this.precision = pieceLabel.precision || 0;\n    this.fontSize = pieceLabel.fontSize || this.options.defaultFontSize;\n    this.fontColor = pieceLabel.fontColor || this.options.defaultFontColor;\n    this.fontStyle = pieceLabel.fontStyle || this.options.defaultFontStyle;\n    this.fontFamily = pieceLabel.fontFamily || this.options.defaultFontFamily;\n    this.shadowOffsetX = pieceLabel.shadowOffsetX || 3;\n    this.shadowOffsetY = pieceLabel.shadowOffsetY || 3;\n    this.shadowColor = pieceLabel.shadowColor || 'rgba(0,0,0,0.3)';\n    this.shadowBlur = pieceLabel.shadowBlur || 6;\n    this.textShadow = pieceLabel.textShadow || false;\n    this.hasTooltip = chartInstance.tooltip._active && chartInstance.tooltip._active.length;\n    this.showZero = pieceLabel.showZero;\n    this.overlap = pieceLabel.overlap;\n    this.images = pieceLabel.images || [];\n    this.outsidePadding = pieceLabel.outsidePadding || 2;\n    this.textMargin = pieceLabel.textMargin || 2;\n    this.showActualPercentages = pieceLabel.showActualPercentages || false;\n  };\n\n  PieceLabel.prototype.checkTextBound = function (left, right, top, bottom) {\n    var labelBounds = this.labelBounds;\n    for (var i = 0;i < labelBounds.length;++i) {\n      var bound = labelBounds[i];\n      var potins = [\n        [left, top],\n        [left, bottom],\n        [right, top],\n        [right, bottom]\n      ];\n      for (var j = 0;j < potins.length;++j) {\n        var x = potins[j][0];\n        var y = potins[j][1];\n        if (x >= bound.left && x <= bound.right && y >= bound.top && y <= bound.bottom) {\n          return false;\n        }\n      }\n      potins = [\n        [bound.left, bound.top],\n        [bound.left, bound.bottom],\n        [bound.right, bound.top],\n        [bound.right, bound.bottom]\n      ];\n      for (var j = 0;j < potins.length;++j) {\n        var x = potins[j][0];\n        var y = potins[j][1];\n        if (x >= left && x <= right && y >= top && y <= bottom) {\n          return false;\n        }\n      }\n    }\n    labelBounds.push({\n      left: left,\n      right: right,\n      top: top,\n      bottom: bottom\n    });\n    return true;\n  };\n\n  PieceLabel.prototype.measureText = function (text) {\n    if (typeof text === 'object') {\n      return { width: text.width, height: text.height };\n    } else {\n      var width = 0;\n      var lines = text.split('\\n');\n      for (var i = 0; i < lines.length; ++i) {\n        var result = this.ctx.measureText(lines[i]);\n        if (result.width > width) {\n          width = result.width;\n        }\n      }\n      return { width: width, height: this.fontSize * lines.length };\n    }\n  };\n\n  PieceLabel.prototype.fillText = function (text, position, fontColor) {\n    var ctx = this.ctx;\n    if (typeof text === 'object') {\n      ctx.drawImage(text, position.x - text.width / 2, position.y - text.height / 2, text.width, text.height);\n    } else {\n      ctx.save();\n      ctx.fillStyle = fontColor;\n      ctx.textBaseline = 'top';\n      ctx.textAlign = 'center';\n\n      if (this.textShadow) {\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n      }\n\n      var lines = text.split('\\n');\n      for (var i = 0; i < lines.length; i++) {\n        var y = position.y - this.fontSize / 2 * lines.length + this.fontSize * i;\n        ctx.fillText(lines[i], position.x, y);\n      }\n      ctx.restore();\n    }\n  };\n\n  PieceLabel.prototype.loadImage = function (obj) {\n    var image = new Image();\n    image.src = obj.src;\n    image.width = obj.width;\n    image.height = obj.height;\n    return image;\n  };\n\n  PieceLabel.prototype.drawArcText = function (str, radius, view, overlap) {\n    var ctx = this.ctx,\n      centerX = view.x,\n      centerY = view.y,\n      startAngle = view.startAngle,\n      endAngle = view.endAngle;\n\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.textAlign = 'left';\n    var angleSize = endAngle - startAngle;\n    startAngle += Math.PI / 2;\n    endAngle += Math.PI / 2;\n    var origStartAngle = startAngle;\n    var mertrics = this.measureText(str);\n    startAngle += (endAngle - (mertrics.width / radius + startAngle)) / 2;\n    if (!overlap && endAngle - startAngle > angleSize) {\n      ctx.restore();\n      return;\n    }\n\n    if (typeof str === 'string') {\n      ctx.rotate(startAngle);\n      var lines = str.split('\\n'), max = 0, widths = [], offset = 0;\n      if (this.position === 'border') {\n        offset = (lines.length - 1) * this.fontSize / 2;\n      }\n      for (var j = 0; j < lines.length; ++j) {\n        var mertrics = ctx.measureText(lines[j]);\n        if (mertrics.width > max) {\n          max = mertrics.width;\n        }\n        widths.push(mertrics.width);\n      }\n      for (var j = 0; j < lines.length; ++j) {\n        var line = lines[j];\n        var y = (lines.length - 1 - j) * -this.fontSize + offset;\n        ctx.save();\n        var padding = (max - widths[j]) / 2;\n        ctx.rotate(padding / radius);\n        for (var i = 0; i < line.length; i++) {\n          var char = line.charAt(i);\n          mertrics = ctx.measureText(char);\n          ctx.save();\n          ctx.translate(0, -1 * radius);\n          ctx.fillText(char, 0, y);\n          ctx.restore();\n          ctx.rotate(mertrics.width / radius);\n        }\n        ctx.restore();\n      }\n    } else {\n      ctx.rotate((origStartAngle + endAngle) / 2);\n      ctx.translate(0, -1 * radius);\n      this.fillText(str, { x: 0, y: 0 });\n    }\n    ctx.restore();\n  };\n\n  function init(chartInstance) {\n    if (chartInstance.options.pieceLabel) {\n      var count = 1;\n      if (Array.isArray(chartInstance.options.pieceLabel)) {\n        count = chartInstance.options.pieceLabel.length;\n      }\n      if (!chartInstance.pieceLabel || count !== chartInstance.pieceLabel.length) {\n        chartInstance.pieceLabel = [];\n        for (var i = 0; i < count; ++i) {\n          chartInstance.pieceLabel.push(new PieceLabel());\n        }\n      }\n    } else if (chartInstance.pieceLabel) {\n      delete chartInstance.pieceLabel;\n    }\n    return chartInstance.pieceLabel;\n  }\n\n  function execute(chartInstance, method) {\n    if (init(chartInstance)) {\n      for (var i = 0; i < chartInstance.pieceLabel.length; ++i) {\n        chartInstance.pieceLabel[i][method](chartInstance, i);\n      }\n    }\n  }\n\n  Chart.pluginService.register({\n    name: 'PieceLabel',\n    beforeDatasetsUpdate: function (chartInstance) {\n      execute(chartInstance, 'beforeDatasetsUpdate');\n    },\n    afterDatasetsDraw: function (chartInstance) {\n      execute(chartInstance, 'afterDatasetsDraw');\n    }\n  });\n})();\n"],"sourceRoot":""}